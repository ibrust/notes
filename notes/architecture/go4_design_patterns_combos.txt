
---------------------------------------------------------
------------------FACTORY METHOD-------------------------
---------------------------------------------------------
aka virtual constructor

factory method | factory method
	"MULTIPLE FACTORIES"
		how is this distinct from an abstract factory? maybe in that the factories vary independently. 
		so does the use of one factory lead to the use of multiple as part of a broader programming style? 

factory method | factory method | adapter 
	"VIRTUAL ADAPTER"
		mappings between 2 sets of objects. 
		this is an interesting way to organize things, it prevents the propagation of many different adapters 
		perhaps it suggests the use of multiple adapters as part of a broader design

adapter | adapter | factory method 
	"COLLABORATING TYPES"
		create adapters between all the different types produced by the factory. 
			now you can easily change an object from one of these types to another
		it may support reuse throughout the application
			for example, if I have a set of related objects - maybe a credit card that's used in many different contexts 
			then a factory could produce these different credit card objects, and the adapters will make subsystems 
				that used these types easier to work with. their APIs will be easy to navigate, it'll be easy to reuse logic between them 
		it may also support a programming style that makes broader use of polymorphism (via an abstract parent class of the factory objects) 
		you're ultimately persisting state between different subsystems & different objects 
		this also adds definition to the types you adapt between - they are related via their common factory

mediator | factory method
	"OBJECT SET CONTROLLER"
		the mediator passes messages between the different objects, and provides them all with fresh information. 
		it also handles initialization / deallocation of objects.
		A common example is a set of views that can be clicked on / backed out of. 
			The view is a factory construct. Clicking allocates / deallocates the view. the views data also has to be kept fresh

observer | factory method | facade
	"FACTORY OBJECT API"
		the factory objects define an API that includes some kind of publisher
		this allows consumers to observe the objects & respond to events while not having to interact with them on a case by case basis 
		the factory objects themselves can then decide which events they want to emit, what functionality they support, etc.
		this seems like a strong way to support the addition of new objects, and reuse of logic for interacting with these objects 
		you will need some abstract base class for the objects 

---------------------------------------------------------
-----------------ABSTRACT FACTORY------------------------
---------------------------------------------------------
prototype | abstract factory 
	"PERSISTING STATE BETWEEN TRANSFORMATIONS"
		something about abstract factories & prototypes is written in Go4. 
		when you change from one set of factory objects to another you may lose all the state associated with the current objects 
		but using prototype constructors you can pass in the existing object to the new object
		and initialize it using the state that needs to be shared. 
		the object used for initialization would need to conform to a common interface so that multiple transitions don't lose data. 
		In real terms I think you'd just put all this configuration data in a data model & pass that in, but the idea is important. 

strategy | command | abstract factory 
	"BUTTONS THAT CHANGE BUTTONS"
		a strategy / command can trigger the changing of UI buttons, and the new buttons turn have different behavior (strategies / commands)
		example is in WoW where clicking a button causes the set of buttons to change, and the new buttons do new things. 

*abstract factory | observer | observer
	"REACTING TO UI CHANGES"
		the abstract factory can listen for events & change its object set based on that 
		it can also emit events to notify subscribers when it changes its object set 
		this just seems to be a recognition that it's important to maintain an update cycle in relation to all these UI changes

---------------------------------------------------------
---------------------BUILDER-----------------------------
---------------------------------------------------------
aka streaming constructor

composite | builder
	"STREAMING PARSER"
		common pattern. a tree is ofter the output of a builder - i.e. the parse tree is the output of the parser
		this is nice because the entire composite structure doesn't have to be in memory at once.
		it would be useful to know how to build a streaming parser in C 

builder | state
	""
		you can use a streaming constructor to create a state object. this may be useful because state objects can take up large amounts of memory. 


state | builder | composite 
	"" 
		

builder | adapter 
	""

visitor | observer | builder 
	"" 

builder | chain of responsibility | facade 
	"" 

---------------------------------------------------------
---------------------PROTOTYPE---------------------------
---------------------------------------------------------

chain of responsibility | prototype 
	"" 

prototype | mediator 
	""

prototype | composite 
	""

prototype | observer 
	"" 

bridge | template method | prototype 
	""
		close to the bridge | template method | interpreter pattern. 
		this sounds like an actual bridge between general methods of a class and some other component that gets inserted at runtime, right? 
		I can see the value of combining template methods and prototypes, but what would be the value of the bridge? 
		what is gained by bridging a prototype? I probably need to think more carefully about prototypes before I answer this. 

command | prototype | facade 
	""

---------------------------------------------------------
---------------------SINGLETON---------------------------
---------------------------------------------------------

singleton | singleton 
	"TENDENCY TO USE MULTIPLE SINGLETONES"
		One singleton often introduces the need for more singletons because of how it alters the programs structure. The use of global state propagates.
		so you should be careful in introducing singletones. Find ways of minimizing the need to use multiple. 

observer | singleton | observer 
	"NOTIFICATION CENTER"
		you can subscribe to a variety of events from anywhere with this pattern 
		or is it the fact you can subscribe globally to a singleton? so you can observe it from here, from there, from everywhere... etc. 
			so not a variety of events per se, just different observers...? It could be either one...

adapter | singleton | facade 
	"GLOBAL INTERFACE"?
		the singleton is a facade to a subsystem, allowing multiple systems to access it. but they're going to need adapters to interact with its interface.

observer | memento | singleton 
	"EVENT EMITTING DATABASE INTERFACE"
		So the memento extracts information & stores it in the singleton. Whenever this happens the singleton emits an event, & this event can be subscribed to. 
		we do data binding but it's often on instances. data binding on a singleton... does this introduce anything interesting? 
			no, I think this is just a choice to use instances where we could have easily used a singleton, it's the same thing though. 

singleton | iterator | singleton 
	"DATA AGGREGATOR"?
		could this be something like our aggregator, that first checks the local and then the remote, and then some other datasources? 

template method | adapter | singleton
	"SINGLETON METHOD IMPLEMENTATIION"
		outside to inside: template method > adapter > singleton 
		you're just calling a method that belongs to the singleton, and since this method is global it needs to be a template method. 
		but then you need an adapter to receive the input from that method, and possibly the output as well. Convert the data to a format compatible with the singleton. 

---------------------------------------------------------
-----------------------STATE-----------------------------
---------------------------------------------------------

state | iterator
	"ADVANCED SEARCH"
		you're just iterating in some fashion to find a particular state. 
		though this is common, it increases the languages power to use a state & iterator design pattern. 
		for example, you can iterate over many different structures in different patterns; and a state object lets you define complex search parameters polymorphically.

state | command
	"CONTEXT-SENSITIVE BUTTON"
		so like the world of warcraft buttons - you click them... then the icon changes & they do something else for a few seconds. 
		They have a state associated with them

state | composite
	"STATUS HIERARCHY"
		You can represent state with a hierarchy. For example, when the element at the top of the heap is the first in alphanumeric order.
		Or lets say a virus scanning application defines different threat levels. The state is being ranked according to some set of values. 

state | iterator | memento 
	"ADVANCED SEARCH & EXTRACTION"
		like advanced search, but now you're saving what you find so that you can reproduce it elsewhere
		the ability to represent in a compact form then reconstruct what you found is a key part of the memento pattern. 

state | command | facade 
	"CONTEXT-SENSITIVE INTERFACE" or "REPRESENTATIONAL INTERFACE"
		it's similar to the context-sensitive button, but there's this complex subsystem you're interfacing with. 
		the interface's state is a simple representation of the complexity contained within the subsystem.  
		The internal function performed changes based on this state. 
		from outside to inside: state > facade > command. It reminds me of a REST API because the state is representational and outside the subsystem. 

state | interpreter
	"CONTEXT-SENSITIVE LANGUAGE"
		this is supposed to be an innovative pattern. I think this is kind of like a context-sensitive language. Look at the example:
		"amazon photos. Users can store thousands of photos. They can also construct these photos into storylines that represent series of events in their lives. 
		A picture is worth a thousand words. Pictures are a language. When you form these pictures into a storyboard, you are saying something about your life. 
		A picture can be interpreted. But a series of pictures can also be interpreted… correct? Like words in a language - a series of statements." 
		It almost reminds me of the command line, where you input something... and then you can input a new set of commands, because your first input 
		effected the state.
		So the interpretation is changing based on state; changing from one interpretation to the next.

state | mediator 
	"KEEPING STATE UPDATED" or "DISTRIBUTED STATE MANAGEMENT"
		application architectures like MVC or MVVM are adept at keeping distributed state updated in response to events.
		The mediation layer sends messages between different components to maintain consistency. 
		asynchronous events & distributed systems make things complicated - network requests, database requests, user input. 
		but even at the hardware level you have this pop up with cache consistency between processors. It also pops up in multithreaded programming.
		this is probably one of the most fundamental patterns

---------------------------------------------------------
-----------------------BRIDGE----------------------------
---------------------------------------------------------

bridge | chain of responsibility 
	"DELEGATION CHAIN"
		So you split up a large class into smaller related classes, then you add a delegation chain between them to defer functionality. That's all this appears to be 

bridge | strategy | proxy
	"ABSTRACT PROXY"
		is this like a proxy that evolves alongside the object it's proxying for? And since both are abstract a strategy determines how the proxy behaves? That actually makes some sense. 
		so this is almost like... an abstract proxy object? 
		this is interesting because the proxy can be for different objects depending on what's needed (as determined by the strategy)

bridge | template method | interpreter 
	"MODIFIABLE INTERPRETER"
		So lets say you're bridging between a class of template methods and a class for an interpreter. 
		this should allow the actual opertions to vary independently of the parsing and interpretation, right? 
		so your language can evolve in one respect, and the actual operations carried out by the language evolve separately. 
		that seems like it would make the language modifiable, backwards compatible and so on. 

---------------------------------------------------------
-----------------------FACADE----------------------------
---------------------------------------------------------

Facade | Decorator
	""
 
Facade | Decorator | Observer
	""

Facade | Mediator | Composite  
	""

---------------------------------------------------------
----------------------MEDIATOR---------------------------
---------------------------------------------------------

mediator | composite | iterator 
	""

mediator | prototype
	""

---------------------------------------------------------
----------------------DECORATOR--------------------------
---------------------------------------------------------

decorator | command
	""

decorator | composite | adapter
	""

decorator | adapter | decorator 
	""

---------------------------------------------------------
----------------------OBSERVER---------------------------
---------------------------------------------------------

observer | iterator
	""

command | observer
	""

---------------------------------------------------------
----------------------PROXY------------------------------
---------------------------------------------------------

proxy  | command
	""

memento  | proxy  | memento 
	"DATABASE PROXY"?
		some kind of object that acts like it contains all sorts of data, but infact internally it's making requests to fetch that data... or something along these lines?
		it sounds like a form of lazy initialization?

---------------------------------------------------------
---------------------INTERPRETER-------------------------
---------------------------------------------------------

command  | interpreter
	""

interpreter  | strategy
	""

interpreter  | visitor  | interpreter		<- the change of a visitor can change the interpretation of a language, bear that in mind
	""

---------------------------------------------------------
---------------------VISITOR-------------------------
---------------------------------------------------------

template method  | iterator  | visitor
	""

---------------------------------------------------------
REMAINING: 
+ 5 more pairs 
+ 25 more triplets 


prototype  | proxy  | observer  | chain of responsibility  | 
state  | iterator  | facade  | memento  | 
state  | decorator  | mediator  | visitor  | 
composite  | template method  | chain of responsibility  | template method  |
command  | chain of responsibility  | facade  | composite 
chain of responsibility  | interpreter  | chain of responsibility  | strategy  |
prototype  | state  | decorator  | strategy  | 	
iterator  | interpreter  | adapter  | abstract factory  |
iterator  | builder  | facade  | facade  | 
builder  | factory method  | decorator  | state  | 

		
command  | interpreter  | decorator  | chain of responsibility  | command 
	// different commands... an interpreter layer that delegates the command to do different things based on decorators? 
	// so some kind of multi-mode command with a layer of changing logic beneath it, or something... 
	// it's more than that, potentially.. the decorator adds a composability to this. 
	// and is able to modify the command, and add something to it 


visitor  | adapter  | decorator  | factory method  | flyweight
state  | visitor  | memento  | adapter  | strategy
abstract factory  | flyweight  | bridge  | facade  | mediator
bridge  | decorator  | abstract factory  | singleton  | flyweight

75+ patterns: 38%+?
single patterns: 21%
random patterns: remainder 
amended by: any other patterns read about. 

---------------------------------------------------------
---------------------DELEGATION--------------------------
---------------------------------------------------------
Delegation | Abstract Factory 
	""

Delegation | Template Method 
	""

Delegation | Interpreter | Template Method 
	""

Delegation | Command | Memento 
	""

Delegation | Strategy | Mediator 
	""

Delegation | Adapter | Strategy 
	""

Delegation | Interpreter | Iterator 
	""