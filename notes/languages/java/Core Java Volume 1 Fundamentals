The Java Development Kit (JDK) consists of over 4000 classes for many things - database support, XML processing, UI construction, security, etc. 
This book covers Java Standard Edition (SE) 9, 10, & 11 
______________________________________________________________________________________________________________________
CHAPTER 1: INTRODUCTION TO JAVA 

Java is not just a language, it is a whole platform with a giant library and execution environment 

Java excluded a variety of C++ features: header files, pointer syntax, structs, unions, operator overloading, virtual base classes, & more 
instead of multiple inheritance, Java uses interfaces 
the pointer model in Java eliminates the possibility of overwriting memory / corrupting data 
One design priority of Java was for it to have a pretty small memory footprint to enable it to run on small machines. 
    Now, Java Micro Edition is used for that

the object files (bytecode) generated by the java compiler are architecture neutral, because they runs in the JVM. 
    bytecode is translated into architecture-specific code via interpretation / JIT compilation

Javas UI libraries portability between all the various OSs remains an issue, but most other Java libraries (even threads) have good portability

jshell, the Java interpreter, was introduced in JDK 9 (i.e. Java 9) and can execute bytecode on any machine it runs on 
    JIT compilation is the more typical method 
Java was originally interpreted (by the VM, not jshell), JIT was added later 

Java generally is more dynamic than C/C++, and is capable of adding & running code at run time 

Java applet: a web program that runs in a java enabled browser 
Java applets are embedded elements within a web page. 
Java applets are generally no longer used, and it requires effort to get them working in a browser 
Java browser plugins do not trust remote code unless it's digitally signed & the user has agreed to its execution, due to past security exploits

Java is generally used in server-side programming and cross-platform client applications 

Oracle has committed to keeping Java opensource, though currently you must pay royalties if developing for embedded systems, 
    but that will end in 10 years. 

Android is built with Java (what part? the apps themselves? the OS?)

______________________________________________________________________________________________________________________ 
CHAPTER 2: THE JAVA PROGRAMMING ENVIRONMENT 

first download & install the JDK (java development kit).
    Remember, on windows you don't want to have spaces in the install path. 
    And remember to update the PATH environment variable correctly 

starting w/ Java 9 you must have a 64 bit OS to use the JDK 

common Java terms: 
    JDK                 Java Development Kit
    JRE                 Java Runtime Environment; for Java 10 or prior, this contains the virtual machine by itself. 
                            so this is not for developers, because it does not contain a compiler.
    Server JRE          the software for running Java on servers

    SE                  Standard Edition; Java platform for use on desktops & simple server applications. 
    EE                  Enterprise Edition; Java platform for complex server applications 
    ME                  Micro Edition; Java platform for use on small devices 
    OpenJDK             opensource implementation of Java SE 

    JavaFX              an alternate tookit for GUIs, included with certain SE distributions prior to Java 11 

    J2                  Java 2; outdated term describing old Java versions 1.2-1.4 and 5.0. Thus you had terms like J2SE SDK 5.0
    SDK                 Software Development Kit; outdated term for the JDK of Java 1.2-1.4 and 5.0. 

    u                   Update; u was Oracles term for an update prior to Java 8, apparently ... 
    NetBeans            Oracles IDE 


to test whether you installed the JDK correctly type in the terminal: 
    
    javac --version 


note that javac / other java CLI tools are migrating from using a single-dash format (i.e. -version) to a more standard double-dash format (--version)

the Java library source files are in the JDK folder under lib/src.zip. 
    for exploration you can create a folder and unzip the source in there 
    if you want more source (for the compiler, VM, native methods, private helper classes) go to http://openjdk.java.net 

you can also download the docs at: www.oracle.com/technetwork/java/javase/downloads 
or read the API documentation for a list of native classes & methods: http://docs.oracle.com/javase/9/docs/api 

to compile & run a program: 

    javac script.java                         // javac is the compiler. this creates a bytecode object script.class 
    java script                               // launches the VM & runs script.class 


the jshell interpreter was added in Java 9:

    jshell                                      // type jshell to run the interpreter
    jshell> "string".length(); 
    $1 ==> 6                                    // $1 is the variable the result was assigned to 
    jshell> 5 * $1;
    $2 ==> 30 
    jshell> int var1 = $2 / $1; 
    var1 ==> 5 

in the shell, press tab while  after writing something to get valid completions. 
    for example, if you press tab after writing an object name and a period you'll get all its methods / properties 

______________________________________________________________________________________________________________________
CHAPTER 3: FUNDAMENTAL PROGRAMMING STRUCTURES 

Java programs have 1 or more classes, and at least 1 main method defined in a class where execution of the program begins
    files can have multiple classes in them
    everything in a Java program must be inside a class 
    the main must be declared with this signature: 


    public static void main(String[] args)                  // void indicates that the main does not return an exit code (unlike C/C++)
                                                            // to terminate with an exit code use System.exit() 

you run a program by specifying the name of the class that contains the main method:

    // Dog.java
    public class Dog {
        private String[] favoriteDogFoods = ["Turkey", "Beef", "Mangos];
        private bone object = new Bone();

        public static void main(String[] args) {                    // notice the keyword public
            ...            
        }

        public Dog() {                                              // constructor 
            ...
        }
    
        public Dog(int legs) {                                      // 2nd constructor 
            ...
        }
    
        public walk(int feet) {
            ...
        }

        private bark() {
            ...
        }
    }

    // terminal
    javac Dog.java
    java Dog

if you have many classes starting with the same prefix you can compile them all using wildcards: 

    javac Plugins/PaymentsTransaction*


when you compile a file, the java compiler searches for all dependency classes and compiles those files also. thus you do not have to specify all files 
if you have old compiled files the java compiler will recompile them automatically if changes were made to the files 

unlike in C++, the name of the program is not stored in the beginning of the args array
you pass args to the main method at compile time:

    java MainClassName arg1 arg2 arg3


there are two basic print methods:

    System.out.println()                // adds a newline to the end
    System.out.print()                  // no newline 


3 types of comments: 

    //
    /* */
    /** */     <- this is used to automatically create documentation strings, discussed later


there are 8 primitive types in Java: 
 
    int             // 4 bytes 
    short           // 2 bytes 
    long            // 8 bytes 
    byte            // 1 byte integer from -128 to 127
    float 
    double 
    char
    boolean 


integer literals can use a variety of syntax: 

    40000000000L            // long 
    0xCA79                  // hex. prefix can also be 0X 
    0447                    // octal 
    0b10010101              // binary. prefix can also be 0B
    1_000_000_000           // underscores can be used for readability
    3.14F                   // float. if theres no F the literal is automatically treated as a double 


note that byte sizes are platform-independent thanks to the JVM, unlike C/C++ 

there are 3 special floating point values: 

    Double.NaN
    Double.POSITIVE_INFINITY
    Double.NEGATIVE_INFINITY


you must use comparisons to test for NaN: 

    if (Double.isNaN(x)) { 
        ... 
    }


if you need large or precise floating point numbers (i.e. for currency) use the BigDecimal class instead.
    but make sure to use BigDecimal's string constructor and not its Double constructor, or you'll still get rounding errors.

char literals are single-quoted strings
    'a' is a char, "a" is a string 

chars can be expressed as unicode literals from \u0000 to \uFFFF 
    unicode literals are preprocessed, so you can use them outside quoted strings, directly within the code, but I don't recommend it:

        public static void main(String\u005B\u005D args) 

    these \u literals can generate a parsing error when used within comments, apparently:

        // c:\users             <-- parsing error - it's interpreted as containing a \u sequence 


originally 1 char mapped to 1 individual character, but now sometimes 2 chars are required to show 1 character 
    i.e. chars are a single code unit in the UTF-16 encoding (2 bytes), where symbols are typically 2 bytes, though can be 4 bytes

like C++, escape sequences include \\, \", \n, \t, etc. 

UTF-8 can be 1-4 bytes, while UTF-16 can be 2-4 bytes. When Chinese, Korean, and Japanese were added to unicode, UTF was expanded beyond 2 bytes 
    this inconsistency introduced complexities when dealing with chars on a byte level 
    for this reason the author recommends avoiding using char unless you're forced to use them

Java does not automatically convert expressions to booleans within test expressions

variable names must start with a unicode letter, _, or $
    they can contain unicode letters, digits, _, or $
    the unicode letters / digits can be in any language

there are nonetheless invalid unicode characters for use in variables. Just stick to the simple letters
    and although $ is a valid letter, it is generally reserved for use by Java internally and should be avoided 

multiple declarations are allowed:

    int x, y, z; 


var is similar to auto in C++. if the type can be inferred from the literal, you can use var.
    note that it can only be used for stack-local variables within methods

    var x = 10;            // automatically sets type to int


to a declare a constant use the final keyword: 
      
    final int x = 12; 

const is a reserved Java keyword that is not currently used for anything 

here's how you declare static properties / methods: 

    public class car{
        public static final short WHEEL_COUNT = 4;

        public static void main(String[] args){    
            ... 
        }
    }


enum variables can either be one of the declared values or null
here's how you declare / use an enum: 
    
    enum Size { 
        SMALL, 
        MEDIUM, 
        LARGE 
    }; 

    Size shirt_1 = Size.MEDIUM; 


integer division by 0 throws an error, but floating point division by 0 yields Double.NaN, Double.POSITIVE_INFINITY, Double.NEGATIVE_INFINITY

in Java 11 there's a strictfp keyword that's used to ensure reproducible values in floating point numbers across different platforms
    strictfp does this by truncating computations to 64 bit numbers (some OS's use 80-bit floating point).
    this truncation decreases performance, and back when 64-bit OS's weren't yet common this wasn't ideal, so strictfp was optional
    but with Java17 and the widespread adoption of 64-bit OS's everything is strictfp automatically now.


    public static strictfp void main(String[] args)             // in Java 11 causes all methods to use strict floating point calculations 


some members of Javas Math class include: 

    Math.sqrt(100); 
    Math.pow(2, 3);             // 8 
    Math.floorMod();            // if you mod a negative number with this the result will still be positive - not so with the regular mod. google for details 
    Math.PI 
    Math.E 
    Math.sin()

to avoid having to prefix these methods with Math every time you can use a static import (more details in CH 4): 

    import static java.lang.Math.*; 


Math performs calculations in floating point registers on the CPU by default.
    this is good for performance but this can introduce unpredictability into the results.
    for total portability but truncation / decreased performance use the StrictMath class instead

also, the following Math methods can be used instead of the conventional operators, and will throw errors if overflow occurs: 

    Math.multiplyExact() 
    Math.addExact()                             // all these can handle both int and long parameters
    Math.subtractExact() 
    Math.incrementExact() 
    Math.decrementExact() 
    Math.negateExact()


chars automatically type-convert to ints 
ints & longs automatically type-convert to floats & doubles. 
    note they can lose precision in the process if the ints / longs are too big

typecasts are done w/ the (type) syntax: 

    double x = 10.5; 
    int y = (int) x;

    int w = 300
    byte z = (byte) w;                      // z = 44  - this typecast truncated the number 

to round a number use (int) Math.round(): 

    double x = 10.5; 
    int y = (int) Math.round(x);            // you must typecast Math.round() because it returns a long. 
                                            // note there is a possibility of information loss

you can't typecast between booleans & other types 

the following operators are the same in Java as C++: 

    assignment operators (including +=, -=, etc.)
    increment / decrement operators (++, --)
    boolean expressions 
    ternary operator
    bitwise operators (& | ^ ~)

bit shift operators (>> <<) are similar, but >> fills the high bits with 1s (logical shift) and >>> fills the high bits with 0s (arithmetic shift)
    in contrast, in C/C++ arithmetic vs logical shift is undefined and implementation dependent

traditional switches have been around since Java 1, and worked the same way as they did in C++. they included fallthrough as well: 

    switch (monoPaymentType) {
    case .affirm:                       // traditional switch uses : at the end of the case 
        launchWebView();
        break;                          // must use break statements 
    case .payPal1x:
        launchWebView();
        break;
    case .payPalBA:
        launchPPBAWebView()
        break;
    case .papEBT:
        selectPAPEBT();
        break;
    default:
        break;
    }


the cases of a switch can only be ints, strings, or cases of an enum 
the operand of a switch can't be null or a NullPointerException is thrown

Java 14 added a new switch that uses the -> syntax instead. these switch's do not fallthrough. 
    you can also create switch expressions where the switch itself will actually return a value
    a special keyword yield is used in switch-expressions. it both breaks and returns a value.
        you can't use return, break, or continue in a switch expression.


    // switch expression
    String seasonName = switch (seasonCode) {
        case 0 -> "Spring";
        case 1 -> "Summer";                 // each branch in a switch expression must yield a value. this shorthand syntax will yield a value.
        case 2 -> "Fall";
        case 3 -> {
            orderWarmClothes();             // in a switch expression, statements that take up more than 1 line must be inside {} and call yield
            yield "Winter";
        }
        default -> throw new IllegalArgumentException("not a valid season");       // it's legal to throw errors in a switch expression
    };

    int numLetters = switch (seasonName) {
        case "Sprint", "Summer", "Winter" -> 6;
        case "Fall" -> 4;
        default -> -1;
    };

    enum Season {
        SPRING,
        SUMMER,
        FALL,
        WINTER
    };

    Season currentSeason = Season.SPRING;

    String heatIndex = switch currentSeason {       // switch expression - won't fallthrough
        case SPRING -> 70;
        case SUMMER -> 90;
        case FALL -> 60;
        case WINTER -> 30;                          // no need for default, all cases are covered
    }

for symmetry Java 14 also added support for the traditional switch statements (with fallthrough) to behave as switch expressions (return a value).

switch statements or expressions are useful in complex control flow.
    prefer the new Java 14 switch over the old one, since fallthrough isn't a problem:

    switch (tenderPlanError) {
        case .pcExpired -> 
            showAlert();
            returnToCart(); 
        case .tpNotInitialized -> 
            showAlert();
            returnToReviewOrder(); 
        case .addCardError -> 
            handleAddCardError(); 
        case .generic -> 
            showAlert(); 
    }


switch statements can also put multiple options on one line (not sure of the old Java 1 switch supports this): 

    switch (result) {
        case .cancelled, .notModified, .success ->
            break;
        case .error -> 
            handleError();
    }


if using old switch's, to detect fallthrough in your code you can compile it with a special flag. the compiler will warn you of any fallthrough.
    if you actually want the fallthrough behavior you can suppress this warning via adding @SuppressWarnings("fallthrough") in the code

    javac -Xlint:fallthrough file.java

Java allows a coma separated list of expressions in the 1st and 3rd slots of the for loop 

the String class is implemented as a char* pointer. the strings themselves are immutable. 
    when you change a String variable, the pointer is just redirected.

the characters in strings are 1 code point (like char) for common characters, 2+ code points for others. 
    so there isn't a guaranteed 1-to-1 mapping between a strings characters and the char type 
        this may be an issue if you're using obscure characters or localizing to foreign languages. 

    String str = "hello"; 
    String str2 = str.substring(0, 3);      // hel - 2nd parameter is the index to stop before 


use + to concatenate strings.
    non string values are automatically converted to strings

String.join() concatenates strings while inserting a delimiter
String.repeat() creates a repeating string: 

    String.join(",", "A", "B", "C");        // A,B,C    
    "v^".repeat(3);                         // v^v^v^ 

Java strings are immutable, unlike in C/C++ 

for efficiency most duplicate strings are shared in memory, but this is not always possible. 
String variables are pointers that point to the string, and you can set a String variable to null. 

you must use special comparison methods to compare strings.
    == will only compare the pointer values. == will work if the string is shared, but unreliably.
    and generally you must test whether the string is null before calling the comparison method on it:

    String str1 = "blah"; 
    String str2 = "blah"; 
    String str3 = "Blah"; 
    String str4 = null; 
    
    if (str1 != null && str1.equals(str2)){ 
        ... 
    }
    if (str1 != null && str1.equalsIgnoreCase(str3)){               // compare but ignores case 
        ...
    }


    int UTF16_unit_count = str2.length();                           // gets the fake length - the number of individual characters in the string
    int code_point_count = str3.codePointCount(0, str3.length());   // gets the true length - the total number of UTF-16 code points used in the string

    char UTF16_unit = str3.charAt(1);                               // get the 2nd UTF16 code character in the string 

    int index = str3.offsetByCodePoints(0, 1);                      // this is how you get individual code points, apparently...
    int code_point = str3.codePointAt(index); 

    int[] code_points_array = str3.codePoints().toArray();          // get an array of integer numbers for all the UTF-16 code points 

    String reconstructed_string = new String(code_points_array, 0, code_points_array.length);      // reconstruct the string from the code points 


to add more madness, the JVM does not have to implement strings as code unit sequences. 
    If there are only 1 byte chars in the string, it can use a byte array. 
    the author recommends not using chars at all due to the numerous complications of using it


java.lang.String is the package for the String class. 
    here are some other interesting String methods: 

    int compareTo(String other);                // return < 0 if String is alphabetically prior to other_string, 0 if equal, > 0 otherwise
    boolean isBlank();                                                  // return true if String consists only of whitespace
    boolean isEmpty();                                                  // return true if String is ""
    boolean endsWith(String suffix);                                    // return true if String ends with the suffix
    int indexOf(String str);                                            // search for str2 in the String. starting_index is optional 
    int lastIndexOf(String str);
    String replace(CharSequence oldString, CharSequence newString);     // return a string with all instances of old_string replaced by new_string 
    String strip()                                                      // remove all whitespace
    String stripLeading()
    String stripTrailing()
    String repeat(int count) 


the String class conforms to the CharSequence interface (covered more later)

Occasionally you need to build up a string from individual characters, such as keystrokes. 
    it's inefficient to use concatenation for this, because a new String object must be created each time. 
    instead you can use the StringBuilder class located in java.lang.StringBuilder (if you really need the performance): 


    StringBuilder strBuilder = new StringBuilder(); 
    strBuilder.append('a'); 
    strBuilder.append('b'); 
    ... 
    String final_string = strBuilder.toString(); 


Java 15 added an easier way to write strings that contain newlines (or just large strings).
    this is mainly useful when added code from some other language: 

    String greeting = """                       // "Hello\nWorld!\n" - notice the first \n is not included
        Hello
        World\                                  // also, \ at the end of the line means to not insert a newline
        !
    """;

    String div1 = """
        <div class="Warning"> 
            Beware of Dogs                      // the line with the least amount of leading whitespace has all its leading whitespace stripped
        </div>                                  // then all the other lines have their leading whitespace stripped by an equal amount
    """;


the Scanner allows you to read input from the command line (you can't do that by default):

    import java.util.Scanner;

    Scanner scanner = new Scanner(System.in);               // route stdin into the scanner

    System.out.print("enter name: "); 
    String name = scanner.nextLine();                       // nextLine() gets a full line of input that was fed into the scanner

    System.out.print("enter your favorite color: ");
    String color = scanner.next();                          // next() just gets a single word, it's delimited by whitespace 

    System.out.print("enter age: "); 
    int age = scanner.nextInt();                            // nextInt() gets an integer. likewise, nextDouble() gets a double. 


you should not use Scanner to read a password from the console, because it's insecure. Instead you must use the Console class, introduced in Java 6: 

    import java.lang.System;
    import java.io.Console;

    Console console = System.console(); 
    String username = console.readline("Username: "); 
    char[] password = console.readPassword("Password: ");


for formatting output Java has the same old printf function. 
    for a list of flags that can be used here read the documentation:   
    
    System.out.printf("%d, %,.2f", 12, 17.457);                         // the , in %,.2f is one such flag which inserts commas in the output 


when using printf with custom objects: 
    if the object implements the Formattable interface the objects formatTo() method is invoked
    otherwise toString() is invoked

you can also use a printf-style format string in the code, or store it in a variable (instead of printing it), via String.format()
    these format strings have an outdated Date formatter, and it's better to use the newer java.time package instead, but here it is:  
        
    String date_string = String.format("%tc", new Date());         // prints the current date/time


Java 15 introduced the formatted() method on strings, which can be used instead of String.format() but works the same:

    String name = "Ian";
    int code = "343664"
    String message = "Hello %s, your code is %d".formatted(name, code);


you can associate the %'s with a specific argument using the $ character. 
    you'd often use this with Date() objects to associate multiple %'s with 1 Date. 
    the < syntax is an alternative, which connects the current % with the previous %'s argument:
    
    System.out.printf("%2$,.2f, %1$d", 12, 17.457);             // 2$,.2f connects with the 2nd arg, %1$d connects with the 1st arg 
    System.out.printf("%.2f, %<d", 12.357); 

note that formatted output is locale-specific.
    i.e. in Germany the group separator will output a period, not a comma. 
    CH7 vol 2 discusses more on to localize applications.

to read from a file you again use the Scanner class. 
    1st arg must use Path.of(). if you used a raw string the scanner interprets it as input data instead of a file
    2nd arg is the files character encoding. this helps with consistency / portability. If not provided the computers default encoding is used: 

        import java.util.Scanner;
        import java.nio.file.Path;

        Scanner scanner = new Scanner(Path.of("file.txt"),              // if the path contains \ (like on windows) remember to use \\
                                      StandardCharsets.UTF_8);          // UTF-8 is useful in reading many web documents
        String line = scanner.nextLine();


to write to a file use the PrintWriter class: 

    import java.io.PrintWriter;

    Printwriter printwriter = new PrintWriter("file.txt", StandardCharsets.UTF_8);


the current directory is determined by where the JVM runs, and this can vary depending on how the program is run (like if you run it in an IDE).
here's how you get the current directory programmatically:

    String current_directory = System.getProperty("user.dir"); 


Java throws an IOException if you try to open a file that doesn't exist or create a file that can't be created. 
    for a method to handle an exception you must use the throws syntax (more detail later): 
    
    public static void main(String[] args) throws IOException {
        Scanner scanner = new Scanner(Path.of("file.txt"), StandardCharsets.UTF_8); 
        ...
    }


another way to handle file i/o is by using i/o redirection when you run the script, combined with using stdin/stdout throughout the code: 

    java scriptname < infile.txt > outfile.txt 


loops & control flow is all identical to C++ with a few exceptions: 

    there's no goto
    there's a labeled break / continue
    something about foreach


some archaic things are identical to C++: 

    ternary operators
    old switch statements
    do while


you can apply a label to any statement using the block syntax. this can be used to simulate goto if necessary:

    label_name:                 // a label can be used by a named break or continue statement. place the label before the block you want to break out of 
    while(true){
        while (true){
            ... 
            break label_name; 
        }
    }

    label_name2:                // apply a label to a plain block to simulate goto 
    {
        ...
        if (condition){
            break label_name2; 
        }
    }


for big numbers there's BigInteger / BigDecimal: 

    import java.math.BigInteger;
    import java.math.BigDecimal;

    BigInteger num1 = BigInteger.valueOf(100);                      // this syntax can be used if the number is small. Not sure why you'd use it, but it exists 
    BigInteger num2 = new BigInteger("123455677345234513456");      // for large numbers

    BigInteger sum1 = num1.add(num2);                               // you must use methods to perform arithmetic operations '
    BigInteger product1 = sum1.multiply(num1); 
    BigInteger sum2 = sum2.add(BigInteger.ONE);                     // BigInteger.ONE is a constant provided by the class. 
                                                                    // there's also BigInteger.ZERO & others

one major downside of Java is it does not allow operator overloading 

Java has a unique array declaration syntax: 

    import java.util.Arrays;

    int[] array1 = new int[100];                    
    int[] array2 = {1, 2, 3, 4, 5};                 // shorthand declaration syntax
    array2 = new int[] {1, 2, 3, 4, 5, 6, 7};       // set the old array variable to a new "anonymous array" 
    int[] array3 = new int[0];                      // weird sytnax for create an empty array (0 length) 

    array1.length;


String arrays without initial values are initialized with nulls, not empty strings.
    int arrays are initialized with 0
    and boolean arrays are initialized with false 


the for:each loop can iterate through anything that implements the Iterable interface: 

    for(int x : array1) {
        ...
    }


you can stringify an array w/ toString() 
to sort an array of integers use Arrays.sort()

when you assign one array variable to another both will point to the same object in memory 
    to get a true copy of the array, use copyOf(). 
    copyOf() is also commonly used to increase the size of an array, apparently

multidimensional arrays are implemented with pointers to arrays. if you want you can change the arrays being pointed to: 

    int[] array1 = {3, 2, 1};

    Arrays.sort(array1);                                                // [1, 2, 3]
    Arrays.toString(array1);                                            // "[1, 2, 3]" 

    int[] array2 = Arrays.copyOf(array1, array1.length * 2);            // 2nd argument specifies how many values to copy, and default initializes the overflow 
    
    int[][] array_2d = {
        {1, 2, 3}, 
        {4, 5, 6}, 
        {7, 8, 9}
    }
    for (int x: array_2d){
        for (int y: x){
            ... 
        }
    }
    Arrays.deepToSTring(array_2d);                                      // "[[1, 2, 3], [4, 5, 6], [7, 8, 9]]"

    array_2d[1] = array1; 
    array_2d[2] = array2;

    int[][] jagged_array = new int[5][];
    for (int x = 0; x < 5; x++){
        jagged_array[x] = new int[x + 1]; 
    }


java arrays have automatic bounds checking built into them 

to get a random number use Math.random(): 

    int roll = (int) (Math.random() * cap);

______________________________________________________________________________________________________________________
CHAPTER 4: OBJECTS AND CLASSES

3 common relationships between objects are: 
    dependence                      // Ys method signatures take an X. Try to minimize dependence, you want to keep objects decoupled
    aggregation                     // aggregation is containment - the Y object contains one or more Xs as properties
    inheritance 

object variables are pointers to the object
create objects w/ new & the object constructor: 

    Date date1 = new Date(); 
    String date2 = new Date().toString();               // you can call methods right off the constructor of an object, though it's may not be efficient
    date1 = null;                                       // object variables can be set to null 


objects are always created on the heap 
the garbage collector automatically cleans up the heap 

to get a true copy of an object you must use the clone method

There are 3 common classes for handling dates: 
    
    Date                                    // handles the timestamp 
    LocalDate / GregorianCalendar           // both these handle the calendar aspect 

LocalDate contains static factory methods, like the Math class. You don't create a LocalDate instance.

with LocalDate / GregorianCalendar you can do things like increment the date by a number of days 

LocalDate's methods return a new LocalDate object, while the old class GregorianCalendar mutates its properties internally (may not be thread safe):

    import java.time.*;

    LocalDate now = LocalDate.now(); 
    LocalDate millennium = LocalDate.of(2000, 1, 1); 
    LocalDate future_date = now.plusDays(1000);                             // increment the date by 1000 days
    int future_day = future_date.getDayOfMonth(); 
    int future_month = future_date.getMonthValue(); 
    int future_year = future_date.getYear(); 

    int current_date = now.getDayOfMonth(); 
    LocalDate past_date = now.minusDays(current_date - 1);                  // sets to start of month  

    GregorianCalendar myahn_date = new GregorianCalendar(2012, 12, 12); 
    myahn_date.add(Calendar.DAY_OF_MONTH, 1);                               // the Calendar class is necessary to work with GregorianCalendar, apparently 
    int survived_day = myahn_date.get(Calendar.DAY_OF_MONTH); 
    int survived_month = myahn_date.get(Calendar.MONTH); 
    int survived_year = myahn_date.get(Calendar.YEAR); 


the Date class has getMonth, getDay, and getYear methods but apparently they're deprecated 

the JDK provides a tool called jdeprscan that can scan your script for deprecated code 

constructors are always called with new, and you can have multiple constructors

a method called off an object that's null will cause a NullPointerException
    you should therefor avoid initializing variables to null, even if it's convenient. 
    but there are two convenience methods for testing whether an object is null before calling a method: 


    String input = Objects.requireNonNullElse(input_value, "unknown");                  // returns the second argument is the test object if null 

    String input2 = Objects.requireNonNull(input_value, "object can't be null);     // throws a NullPointerException exception if null
                                                                                    // same as a runtime error, but it throws immediately
                                                                                    // in Java 17 the default error message is very descriptive now

the "this" keyword is optional and a question of style. the target object is assumed implicitly 

there are advantages to using getter / setters over public variables. for example, you can ensure that nulls aren't accessed / do error checking in them

make sure you do not return references to mutable objects from methods. 
    the mutable object will get passed around and mutated all over the place. 
    always clone objects that you're returning:


    private Date private_date;                  // try to keep properties as private as possible, especially object references

    public Date date_getter() {
        return (Date) private_date.clone();
    }


final (immutable) variables must be initialized in the constructor, and cannot be changed afterward 
    note that final reference variables merely will never change the object they point to - but the object itself is mutable 

use static methods when you only need to manipulate static variables or input parameters - i.e. Math.pow()

you can access static variables / methods off the class name or off an actual instance

static methods are often used to implement factory methods.

the main method is static so that it can be called without first creating an object 
    every class can have a main method. this is one way of unit testing - add mains to your test classes and run them independently

all arguments are pass by value, but with objects/arrays you're passing the pointer by value. 
    so the object can be modified. however, you couldn't change the pointer.
    so a method can't make the pointer refer to a new object/array, but it can change the object/array itself
       so take careful note of whether the methods you're calling on a reference variable are mutating or non-mutating

overloading works like in C++ - by matching signatures, including the type of parameters.
    you can overload any method, including constructors 

a methods signature is considered to be just the names & parameter types, but doesn't include the return type.
    so you can't have 2 methods that only differ by their return types.

private properties are initialized to 0/false/null if not set in the constructor, but stack-local variables are not.
    a default constructor will set all private properties to 0/false/null 
    if you define any constructor for a class the default constructor is no longer provided 

to avoid accidental null Strings (incase a constructor forgot to set the string) always first set Strings to "" when they're declared 

you can initialize the privata properties when they're declared too, or by using static methods:

    class Soldier {
        private String name = "unknown"; 
        private int id = get_id(); 
        private static int count = 0; 
        
        private static int get_id(){
            count++; 
            return count; 
        }
    }


the first line in a constructor can be a call to another constructor of the same class.
    this is done via calling this(): 

    class obj2{
        private int data_1; 
        private int data_x;
        obj2(){
            data_1 = 1; 
        }
        obj2(int x){
            this();                 // this() must be at the first line of the constructor 
            data_x = x; 
        }
    }


there are also initialization blocks which always run before any constructor 
    be sure to always put your initialization blocks right after the declarations of all private variables. this is for compilation reasons.
    all initialization blocks in the class are run prior to constructors, but using only one block is simpler
    initialization blocks remind me of required inits:

    class obj3 {
        private int id; 
        private static int count = 0;           // a field initializer is the term for setting the property at the declaration site 
        private String name; 
        
        {                   // initialization block 
            count++;        // here you put code that you want to run every time this class gets initialized, regardless of the init that's used
            id = count; 
        }

        obj3(String name){
            this.name = name;       // this.name avoids having to come up with different names 
        }                           // this can also be used within constructors to invoke other constructors of the same class
    }


when a constructor is called the following steps occur in order: 

    1) if this() is found on the first line, that constructor is invoked 
    2) all instance variables are initialized to 0/false/null 
    3) all field initializers and initialization blocks are run
    4) the constructor runs 


there are also static initialization blocks to initialize static variables. these run during compilation: 

    class obj4 {
        private int id; 
        private static int count;               // in this case count isn't initialized using a field initializer 
        
        static                                  // precede the initialization block with static to make it a static initialization block 
        {
            count++; 
            id = count; 
        }
        ...
    }


Java 17 improved the Random package by adding more algorithms with various tradeoffs:

    // the newer Java17 package
    import java.util.random.RandomGenerator; 

    RandomGenerator gen = RandomGenerator.of("L64X128MixRandom");       // the algorithm L64X128MixRandom is suitable for most things
    int number = gen.nextInt(100);                                      // random number from 0-99


    // the older Java8 package
    import java.util.Random; 

    Random gen2 = new Random();
    int number2 = gen2.nextInt(100);                                    // random number from 0-99


Java does not have destructors, and has automatic garbage collection. 

Sometimes you do need to close things before the object is cleaned up (i.e. database connections). There are 4 ways of doing this: 

    1) define a close method to call when you are done with the object (CH7)
    2) use Runtime.addShutdownHook to perform the cleanup once the JVM exits 
    3) use the Cleaner class (java 9) to register an action that's performed prior to garbage collection 
    4) there's a deprecated method called finalize that's unreliable and should never be used 


Java 14 & 16 added Records, which are like structs (Swift) or dataclasses (Python). 
    Records are immutable and publicly readable. 


    record Point(double x, double y) {                                      // example record declaration

        public Point() {
            this(0, 0);                                                     // custom constructors must always call the canonical constructor
        }

        public double distanceFromOrigin{
            return Math.hypot(x, y); 
        }
    }


the properties passed in to the Record at declaration are synthesized into private final properties by the compiler (so they're immutable).
    then public getter methods are synthesized (but not setter methods).

records get a canonical constructor automatically synthesized, which contains parameters for all properties.
    any custom constructor you define must ultimately call this canonical constructor.
    you can't read or set the instance variables within the custom constructor, that occurs in the canonical constructor.

records also get 3 methods automatically synthesized: 

    toString()
    equals()
    hashCode()

records can have methods, static variables / methods, but you can't add instance variables to them. 
    the only instance variables they can have are those passed in & synthesized at declaration.

records are intended to be more efficient safer in concurrent programs
    though it is possible, avoid passing object references as parameters to a record since this undermines its immutability, which is its purpose 


packages are used to group related classes. multiple files can specify the same package name. 
packages provide a unique namespace for the classes and modularizes the code 

you can have nested packages, but the compiler will assume there's no relationship or connection between them.
    so java.util and java.util.jar each act as an entirely separate collection of classes, and are compiled separately.

you can access any public class from another package by using the package name or an import statement: 

    java.time.LocalDate today = java.time.LocalDate.now();              // access via package name 
    

    import java.time.*;                 // you can import a specific file, class, or the whole package this way. 
                                        // but importing them all doesn't effect code size 
    LocalDate today = LocalDate.now();  // importing specific files / classes instead of using * is mainly useful for avoiding name conflicts


import does not work like include - the imported file is not pasted into the code, the java compiler finds the code 

the * import syntax can only import a single non-nested package

since you can use classes without import by typing out their full pathname, the purpose of import is just convenience

importing a static method or field requires a special syntax: 

    import static java.lang.System.*;


to put the classes in a file within a specific package use the following syntax: 

    package packageName;                // this always goes on the first line
                                        // the folder path is relative to where the program is run, and includes everything besides the filenames 
    class obj1{
        ...
    }


and the path to the file must match the package name. 
    i.e. all files in the plugins.paymentsTx.coordinators package must be within the plugins/paymentsTx/coordinators folder
    note that the compiler does not check the directory structure when it compiles.
        if a file is in the wrong directory compilation will succeed, but the virtual machine won't be able to find the file when you run it.

all classes that are not manually placed in packages are automatically placed in the "unnamed package", including the main file

a file can contain only 1 public class (but can contain many private ones).
    the public class name must match the file name.

if you don't specify private or public for a class, method, or variable, any other class within the package can access it. 
    so anyone working in your code can just add their file to your package and have access to all your private data structures.
        this is why you can't add classes to the built-in java packages - it'd allow you to modify the source behavior.
    therefor you should always set your variables / methods private unless there's reason not to.

classes can also be stored in JAR files.
    JAR files are zipped archives of folders / files (class files, images, sound files, etc.)
        they use the ZIP format, so you can use any zip utility to look inside
    usually 3rd party libraries come as JAR files 

here are the steps to sharing classes amongst different programs:

    1) put your files in a directory. if you're creating a package, make sure the package name is relative to the base directory 
    2) include any JAR files within the same directory
    3) set the CLASSPATH environment variable
        CLASSPATH  tells the JVM which folders or JAR files to search for classes, JARS, & packages in

        you can add new paths to CLASSPATH in the shell config file, but this is error prone. 
            in the past poorly written installers globally set CLASSPATH incorrectly (didn't include current directory) and caused build errors
        the following is the best way to set CLASSPATH - you set it when you run the program. 
            this is safer because it doesn't actually modify the environment variable (if you know what you're doing this probably isn't needed though): 

            // on UNIX
            java -classpath .:path1:path2:path3 program_name                // UNIX uses : to separate paths 
            
            // on Windows
            java -classpath .:path1;path2;path3 program_name                // Windows uses ; 
        
        
        you can use the wildcard (*) to add a folder of multiple JARs to CLASSPATH (note: it must be escaped via \* in UNIX)

        you must always include "." (the current directory) when you set the path. 
            javac looks in the current directory for files, but the JVM won't look there unless you include this. 
                so if you forget this the classes will compile, but they won't run.

when searching for a class used in a file, the compiler will check everything the file imports at every path in the class path. 
    it will throw a compile error if multiple classes of the same name are found.
    java.lang is imported by default, so this will always get checked.
during this process the compiler also checks if the imported files have been modified since last compilation, and if so it recompiles them.
    within a package if you import classes that aren't public (named differently than the file) the whole package must be searched

there's a new alternative to setting CLASSPATH in Java 9 - classes can be loaded from the module path (read CH9 of volume 2 for details)

the JDK includes a jar tool to create JAR files: 
    jar cvf jar_file_name.jar file1 file2 file3 ...                      // jar options (cvf) are similar to tar options

each JAR contains a file MANIFEST.MF in the META-INF directory. 
    this file contains information about the JAR archive. you can edit it - read the docs for more info
    note that the last line in the manifest must end w/ a newline character or the parser will screw up 

you can specify an entry program for the JAR file to make it executable. 
    you can do this with the "e" command line option, or in the manifest (see pg 194)
    you can then run the JAR executable using java -jar: 

        jar cvfe jar_file_name.jar entry_program file1 file2 file3 ...
        java -jar jar_file_name.jar


on Windows there are wrapper utilities that turn JAR executables into Windows executables - Launch4J adn IzPack are 2 of them 

when Java9 introduced modules and strong package encapsulation it changed the way classes were compiled and linked.
    library providers needed to compile their code differently based on the version of Java being used.
    Java provides multi-release JARs to facilitate this.
in multi-release JARs there's a META-INF/versions folder where you can put different source files for different versions of Java.
to add multi-release class files to an existing JAR or create a multi-release JAR you must compile using --release (see pg 202 for details) 

the JDK contains a tool called javadoc that generates HTML documentation from comments starting w/ /** in your source files 
    this way documentation + code are the same place place 

to document the file, place a comment /** ... */ immediately above each of the following: 
    modules
    packages
    public classes & interfaces
    public & protected fields
    public & protected constructors & methods

these special comments contain text, and can also contain certain tags that start w/ the @ symbol - i.e. @throws, @param, etc.
    these tags are rendered in special ways in the HTML. 
you can make HTML links to resources (i.e. images) in the comment.
    to do this create a subfolder next to the source file named "doc-files" & use it as the src: 

    /** it's a card class! <img src="doc-files/card.jpg" /> 
        @author ian rust */
    class card{
        ...
    } 

some specific tags include: 

    @param {variable description} 
    @return {return description}
    @throws {exceptions description}
    @since {description of the version that introduced this feature}
    @author {authors name, etc.}
    @version {description of current version}
    @link {links}
    @see {reference to other documentation section}

@link and @see require a specific format. google for some examples: 

    @see package.class#feature label <a href="...">label</a>"text"      // if you omit package or class the current package or class will be used 
    @link package.class#feature label                                   // all the elements appear somewhat optional / flexible 

to turn the documentation into HTML files go into the root directory of the documentation and run one of the following commands: 

    javadoc -d extraction_folder package_name1                        // for just 1 package. extraction folder is the new folder where the HTML will be stored 
    javadoc -d extraction_folder package_name1, package_name2, etc.   // to document multiple packages 
    javadoc -d extraction_folder *.java                               // for files in the unnamed package 

javadoc has more options that you can google

some principles of class design to remember: 
    1) initialize all data in some manner 
    2) only provide getters / setters to fields that need it
    3) make instances immutable, and instead of mutating them, return new objects. this makes them thread-safe 

______________________________________________________________________________________________________________________ 
CHAPTER 5: INHERITANCE 

public, protected, & no-modifier properties are inherited
    but no-modifier properties are only accessible to subclasses in the same package
public is accessible to everything, while no-modifier / protected properties are accessible to everything within the package 

Java uses the extends keyword for inheritance: 

    class Dog extends Animal {
        ...
    }


super is used to access the parents members
super uses a special syntax to invoke the parents constructors 
    any call to a super constructor must be on the very first line of the constructor
a super constructor must always be called. 
    if you do not manually call a super constructor the parents default constructor is called automatically. 
    but if the parent has no default constructor an error is thrown: 


    class type2 extends type1{
        ...
        type2(int x){
            super(x);                       // calling a super constructor is required
            ...
        }
        method_name(int x){
            super.method_name(x);
            ...
        }
    }


all overridden methods support polymorphism by default, and the keyword final is used to disallow polymorphism. 

Java does not support multiple inheritance, but it does support inheritance chains.
    use interfaces for the alternative to multiple inheritance (like swift)

parent array variables can point to their childs arrays. Java runtime monitors these polymorphic arrays to ensure parent elements are not stored in child arrays 

when overriding methods you can't change the return type except to a subtype of the original return type 

private / static / final methods are statically bound. construtors are also statically bound.
    all other function calls are dynamically bound & therefor support polymorphism

child methods must be at least as visible as their parent methods - i.e. if parent is public, child must be public 

final classes cannot be extended
final methods can't be overrridden
final fields are const
all methods in a final class are made final (but not fields)

classes should generally be made final unless you need the polymorphism or inheritance. the compiler can inline & optimize the bound final methods this way

enumerations and records are always final

try to use polymorphism instead of typecasting objects if possible. the typecasting may be a sign of design problems.
    an incorrect typecast will throw a runtime error. 
    for safety use instanceof to check if a cast succeeds first, because instanceof does not throw a runtime error:


    Animal animal = (Animal) dog;

    if (animal instanceof Dog) {            // instanceof checks that this is a valid type conversion, avoiding an runtime error 
        myDog = (Dog) animal; 
        myDog.bark();
    }


testing for class membership then assigning the object to a variable is common enough that Java16 added pattern-matching support for it: 

    if (animal instanceof Dog myDog) {                  // check for membership and assign to the myDog variable
        myDog.bark();
    }

    if (animal instanceof Dog myDog && myDog.hoursSinceWalked > 5) {    // you can use the new variable in the same expression via && 
        myDog.walk();                                                   // but note that || would cause a run-time error since it doesn't short-circuit
    }

    int hoursSinceWalked = animal instanceof Dog mydog ? myDog.hoursSinceWalked() : 0;      // the ternary operator also short-circuits


Java 17 extended this pattern-matching variable declration to switch statements: 

    boolean needToWalk = switch(animal) {
        case Dog myDog -> myDog.hoursSinceWalked() > 5;
        case Bird -> false;
    }


use the abstract keyword to make a class/method abstract

    public abstract class obj1 {     // abstract classes have at least 1 abstract method 
        ... 

        public abstract String method1();       // no implementation
    }

the Java primitives are numbers, booleans, and chars; everything else is a class.
    all classes in Java extend / trace back to the Object superclass

a variable of type Object can hold anything except primitives, though it's only useful to store things unless you know what the method calls should be: 

    Object obj = new Dog(); 
    Dog dog = (Dog) obj; 


Object defines important methods that the other classes inherit 
Object's equals() method tests if two variables refer to the same object. 
    to test whether two objects have the same state you must override equals() in the class
    be sure to implement equals() at all levels of your class hierarchies: 
    

    import java.util.Objects
    
    @Override public boolean equals(Object rvalue){     // note: the parameter must be of type Object to successfully override the Object.equals() method
                                                        // @Override is a decorator. If you mess up the parameters and don't override anything, it throws an error
        if (this == rvalue){                            // if the two are the same object, return true
            return true; 
        }
        if (rvalue == null){                            // rvalue is null, return false. 
            return false;                               // equals() should return true if both are null, false if only 1 is null 
        }
        if (this.getClass() != rvalue.getClass()){      // classes don't match, return false
            return false; 
        }

        // now test the state of the two objects
        if (this.dog.equals(rvalue.dog)                                             // here we call equals() to ensure correct handling if dog is null
                && this.libraryTimeRemaining == rvalue.libraryTimeRemaining) {      // no need to use equals() for an integer field, since it can't be null
            return true; 
        }
    }


for equals() comparisons between sibling classes use instanceOf() instead of getClass(). 
    but only implement instanceOf() in the parent in a final equals() method - otherwise the comparison won't make sense.
    so you use instanceOf() to make sibling class comparisons work, and getClass() to ensure same-class comparisons work 

there are a few methods for calculating unique hashcodes for objects using their memory addresses:

    // defined in java.lang.Object
    int hashCode()                      // called off the object, and returns a hash for it. 

    // defined in java.util.Objects
    static int hashCode(Object a)       // returns 0 if a is null, otherwise returns a valid hash
    static int hash(Object... objects)  // returns a hash code for a variadic list of objects. it does this by calling Objects.hashCode() for each object
                                        // so it is null safe

if you override equals() you must also override the hashCode() method in java.lang.Object if you want your object to work with Java's hash tables
    to do this, calculate the new hashcode using all those fields that were used in the equals() comparison: 

    import java.lang.Object;
    import java.util.Objects;

    public int hashCode() {
        return Objects.hash(string_field, double_field, date_field); 
    }


the String class (and numerous other classes) override Object's hashCode(). Strings get a unique hashcode based on the letters of the strings

to compare arrays use Arrays.equals() instead of the default Object.equals()
    there's also Arrays.deepEquals() for comparing  multi-dimensional arrays
    and Arrays.hashCode() to create a hashcode from an array.

records are convenient because they automatically synthesize equals(), hashCode(), and other things

Object.toString() is another important method that stringifies objects. override it to stringify your objects.
    conventionally the resulting strings have the class name followed by field/value pairs inside square brackets: 
    
    public class obj1 {
        ...
        public String toString(){
            return getClass.getName() + "[field1=" + field1 + ",field2=" + field2 + "]";
        }
    }

    public class obj2 extends obj1{
        ...
        public String toString(){                   // a 2nd pair of brackets is the common way of overriding toString() in subclasses
            return super.toString() + "[field3=" + field3 + ",field4=" + field4 + "]";  
        } 
    }


toString() is invoked by the Java compiler when objects are concatenated, and in output operations. 
    It's very useful in debugging and should be overridden.
    Object.toString() (the default) simply prints the class name followed by a hashcode for the object 

to stringify arrays use the static Arrays method. array's toString() method inherited from Object outputs in a very archaic format and shouldn't be used: 

    Arrays.toString(array1)             // normal array 
    Arrays.deepToString(array2)         // multidimensional arrays 


another trick is, instead of calling toString() directly, to use concatenation to get the string. 
    toString() can only be called off Object types, but won't work on primitives. concatenation works with both: 

    String description = "" + x;            // x is stringified as part of concatenation


the size of a regular array can be initialized using variables, and is static afterwards: 

    int num1 = 20; 
    var array1 = new obj1[num1];
    int permanent_length = array1.length; 


ArrayList is Java's equivalent of Vector 
there are multiple ways of declaring an ArrayList:

    import java.util.ArrayList;

    ArrayList<Fish> fishlist1 = new ArrayList<Fish>(200);   // the vector starts with 200 potential elements
                                                            // note that the ArrayList doesn't have elements yet, it just has space available.

    var fishlist2 = new ArrayList<Fish>(200);               // var works in Java10+ 

    ArrayList<Fish> fishlist3 = new ArrayList<>();          // if you specify the type parameter on the left you don't need to specify it on the right

    var fishlist4 = new ArrayList(200);                     // note that ArrayList without <> will create an ArrayList of raw Object types 


ArrayList was created before Java added generic type constraints.
    so an ArrayList<> or ArrayList just uses the Object type. ArrayList<Dog> is the type constrained version.
    at runtime, all ArrayLists are all compiled down to the unconstrained version

    this means typecasts to either ArrayList or ArrayList<Dog> are indistinct after the code has been compiled down.
        mistakes like adding the wrong type to an ArrayList<Dog> are possible, and don't get caught by the compiler. 
        and you can pass a constrained ArrayList<Dog> to a method that takes an unconstrained ArrayList
            this can cause bugs - within that method the wrong type could get added to your list

        and ArrayList's add() / set() are dangerous because they don't do type checking. 
            if you add the wrong type of element it will cause a runtime error when you get() it & cast it later. 

    for safety the compiler will show warnings in these situations. if you're satisfied with the behavior you can suppress these warnings: 

        @SuppressWarnings("unchecked") ArrayList<Dog> dogs = (ArrayList<Dog>) untypedList.find(myDogs);


here are some common ArrayList operations:

    // capacity & sizing
    fishlist1.ensureCapacity(1000);                 // expands capacity in one operation. more resource efficient if you have an idea how much you need  

    int current_length = fishlist1.size();          // size() returns the actual number of elements in the vector, not the max capacity
                                                    // size() for arrayLists is like length for arrays

    fishlist1.trimToSize();                         // trim the ArrayList to match the current size - useful if you don't need all the capacity
    

    // CRUD methods
    fishlist1.set(3, new Fish("fishfood"));         // you can't use [] w/ an ArrayList (java doesn't support operator overloading)
    obj1 temp = fishlist1.get(3); 

    for (int x = 0; x < 30; x++) {                  // add() will expand the capacity of the array if needed. set() will not.
        fishlist1.add(new Fish());                  // so only use set() to replace existing elements, not to add new elements.
    }

    fishlist1.add(15, new Fish());                  // inserts an element into the middle 
    fishlist1.remove(12);                           // remove an element from the middle 


    // foreach loops
    for (Fish x : fishlist1) {
        x.swim();
    }

    // converting to an ArrayList to a regular Array - this is useful to avoid dealing with the ugly syntax of ArrayList
    var fishlist5 = new Fish[fishlist1.size()]; 
    fishlist1.toArray(fishlist5);


all the primitives have associated wrapper classes:

    Integer
    Long
    Float
    Double
    Short
    Byte                    // the first 6 here are all subclasses of Number
    Character
    Boolean

if you want an ArrayList of integers you're forced to use the wrapper class, because ArrayList can't support primitives directly: 

    var int_list = new ArrayList<Integer>();


primitives will get wrapped / unwrapped automatically in certain circumstances (much like in javascript).
    note that this wrapping / unwrapping occurs at compile time, not runtime.


    int_list.add(3);                        // 3 is automatically wrapped by Integer 
    int_list.add(Integer.valueOf(3));       // the code compiles to this

    int n = int_list.get(1);                // the return value is automatically unwrapped
    int n2 = int_list.get(1).intValue();    // the code compiles to this


the wrapping / unwrapping is mostly invisible, but not always.
    the == operator, when applied to objects, only checks for identical memory locations. 
    so if you use == to with Integer objects the behavior is unreliable, and will usually fail.
        it won't always fail because sometimes the compiler optimizes the code to reuse the primitive wrappers.
            this wrapper reuse is actually required by the java specification for 1 byte literals - i.e. ints from -127 and 128, but don't rely on it 
        they couldn't override the comprision operator because Java doesn't allow overriding of operators.

    so instead when comparing wrapped numbers you must use equals():

    if (x.equals(y)) {              // here if x or y are primitives they'll just get autoboxed, so this call is safe
        ...
    }


also, since it's possible for reference variables to be null, operations that automatically unwrap can throw a NullPointerException.
    so never assign null to a wrapper type. better yet, never construct one - just let the runtime handle wrapping / unwrapping.
    the wrapper constructors are actually scheduled to be deprecated:


    Integer n = null;
    System.out.prin(2 * n);                 // throws NullPointerException - unwraps the null object


if you use both an Integer and Double type in an expression, the Integer type will be unwrapped then rewrapped as a Double

these wrapper classes also contain important static methods related to their type: 

    String numberString = "12345";
    int n = Integer.parseInt(numberString);


remember that primitives are pass by value, but objects are pass by reference. 
    so you'd assume a method could produce side effects if you pass it the wrapper type.
    but to prevent this, the primitive value in the wrapper object is immutable. 
        in operations the compiler will automatically create / return a new wrapper object

    public static void triple(int x) {              // does nothing - the calling code isn't modified
        x = 3 * x;
    }

    public static void triple(Integer x) {          // also does nothing
        x = 3 * x;
    }

if you want this side-effect behavior you can use the org.omg.CORBA package, which defines IntHolder, BooleanHolder, & others:

    public static void triple(IntHolder x) {          // modifies the parameter that's passed in
        x.value = 3 * x.value;
    }


methods can have variadic parameters. within the method implementation the variadic parameter is handled just like an array. 
    here is how printf / max are defined: 

    public class PrintStream {
        public PrintStream printf(String ftm, Object... args) {         // the elipsis ... is for variadic parameters
            return format(fmt, args);
        }
    }

    public static double max(double... values) {
        double largest = Double.NEGATIVE_INFINITY;
        for (double v : values) {
            if (v > largest) {
                largest = v
            }
        }
        return largest;
    }


it's also legal to pass an array as the last argument to a variadic parameter. 

enums are actually implemented internally using classes. each case has 1 instance associated with it. 
    for this reason == does accurately compare enum cases with one another 

you can add methods / properties / constructors to an enum:

    import java.util.Enum;

    public enum Size {

        SMALL("S"), MEDIUM("M"), LARGE("L");

        private String abbreviation 
        
        private Size(String abbreviation) {             // this is the constructor - it's invoked when the enum case is created 
            this.abbreviation = abbreviation;           // enum constructors are always private. you can omit the private keyword & it'll private by default.
        }

        public String getAbbreviation() { 
            return abbreviation; 
        }
    }


all enums are subclasses of the Enum class, which has some useful methods:

    Size.SMALL.toString();                          // returns the case name as a string - "SMALL"

    Size s = Enum.valueOf(Size.class, "SMALL");     // sets s to the case Size.SMALL 

    Size[] allCases = Size.values();                // returns [Size,SMALL, Size.MEDIUM, Size.LARGE]

    Size.MEDIUM.ordinal();                          // returns 1 
                                                    // ordinal() returns an int of the cases position in the declaration list, starting from 0


sealed classes (added in Java 17) allow you to restrict subclassing to just a certain set of classes.
    contrast this with final which prevents all subclassesing. 
    one of the advantages of sealed classes is improved compile-time checking.
    they also can ensure that polymorphic code doesn't get misused by random subclasses.

the subclass of a sealed class must declare themselves as final, sealed, or non-sealed (open to subclassing):


    public abstract sealed class LargeMammal permits Dog, Moose, Bear, Human, Whale {

        public String makeNoise() {                     // switches work with sealed classe 
            return switch (this) {                      // the compiler checks every case is covered - no default is required
                case Dog dog -> "ruff!";
                case Moose moose -> "rrruuuaahhh";
                case Bear -> "grunt";
                case Whale -> "click";
                case Human -> "hello!";
            }
        }
    }

    public final class Dog extends LargeMammal {        // subclass declares itself final 
        ...
    }


the subclasses of a sealed class must be accessible from the sealed class. 
    if these subclasses are public the rules are more stringent - they must be in the same package as the sealed class.

the reflection library allows you to introspect classes in a variety of ways.

Java maintains a type identifier for all objects during runtime. 
    the class named Class allows you to work with this information at runtime: 


    import java.lang.Class;
    import java.lang.reflect.Constructor;                   // newInstance() is defined here in reflect 

    Dog dog = new Dog();

    Class class_obj = dog.getClass();

    System.out.println(class_obj.getName());                // if the class is in a package the package name is part of the class name
                                                            // note that, for historical reasons, getName() returns obscure names for array types
    String className = "java.util.Random";
    Class class_obj2 = Class.forName(className);            // obtain a Class object using the class name (seems fragile)
                          
    Class class_obj3 = Double[].class;                      // or just get a Class objects using the actual class
    Class class_obj4 = int.class;                           // note that int is a primitive type, not a class, but nonetheless has an associated Class object
    Class class_obj5 = Dog.class;                           // Class objects really describe types, not classes.


    Object dog = class_obj5.getConstructor().newInstance();             // a Class object can get its classes zero-argument constructor via getConstructor()
                                                                        // you can then construct instances of that class
                                                                        // but if the class doesn't have a zero-argument constructor this call will throw


Class is actually a generic. Dog.class actually returns an object of type Class<Dog>
    the virtual machine manages a unique class object for each type.
    therefor you can use the == operator to compare class objects.
    unlike instanceof comparisons, class comparisons don't evaluate true for subclasses:


    if (obj1.getClass() == Dog.class) {
        ...
    }


there are 2 kinds of exceptions: checked and unchecked. 
    the compiler validates that you're handling checked exceptions, but it doesn't validate unchecked ones. 

if a method contains a checke exception you have to add a throws clause at the end.
    any method that calls this method will also need a throws clause:


    public static void feedDog() throws NullPointerException {
        dog.eat();
        dog.walk();
    }


the Class class provides a somewhat hacky service for locating resources (images, text files etc.):

    var class_obj = DogResources.class;                 // get the class object of a class that contains resources

    URL url = class_obj.getResource("dog.gif");         // some classes, such as getImage() in the ImageIcon class, 
                                                        // have methods that accept URLs for fetching resources
                                                        // if the class doesn't have one of these methods you'll need to call getResourceAsStream()

the point is that the JVM knows how to locate a class, so it can then search for the associated resource in the same location.
    i.e. lets say DogResources is in the dog package. this means it's in a Dog/ directory. 
        place your resources in the same directory as the class file and you'll be able to access them via these methods
        you can also place the resources in a location relative to Dog/ and use a relative URl to access them


the rest of the reflection API is very niche meta programming that you probably won't need for a while. 
    rd pg 287, 5.9.4 for the remainder of it.


______________________________________________________________________________________________________________________ 
CHAPTER 6: INTERFACES, LAMBAD EXPRESSIONS, AND INNER CLASSES

here's an example of a Java interface:

    // the Comparable interface before Java 5
    public interface Comparable { 
        int compareTo(Object otherObject);                  // requires the implementor to use the Object type 
    }

    // a generic interface was provided for Comparable in Java 5 - though you can still use the non-generic if you like
    public interface Comparable<T> { 
        int compareTo(T other); 
    }


all methods defined by an interface are automatically public

interfaces can define constants. but they can never have instance variables

to conform to an interface use the implements keyword:

    class Dog implements Comparable {
        public int compareTo(Object otherObject) {                  // note the implementor must declare the conforming method public
            Dog other = (Dog) otherObject;                          // compareTo should return -1 if self < other, +1 if self > other, & 0 if the two are equal
            return Integer.compare(self.height, other.height);      // Integer.compare() already has the correct behavior
        }
    }

    class Dog implements Comparable {
        public int compareTo(Dog other) {                           // conform to a generic interface
            return Integer.compare(self.height, other.height); 
        }
    }

usually you should use equals() to test for equality within the implementation of compareTo().
    one exception is in BigDecimal, where there's strange behavior when doing comparisons:

    x = new BigDecimal("1.0");
    y = new BigDecimal("1.00");

    if x.equals(y) {                    // equals() here will return false because the numbers have different precision
        ...
    }
    if x.compareTo(y) {                 // apparently this will still return 0 though
        ...
    }


after conforming to Comparable you can use built-in methods like Arrays.sort(). 
    but note that Arrays.sort() will throw a runtime error if you call it and your type doesn't conform to Comparable. 
        the compiler won't type-check this for you due to the buggy way Arrays.sort() is coded to accept an Object[] and not a Comparable[] 

compareTo() is complicated by inheritance. 
    it is the caller's comparator method that will be invoked. but compareTo() should compare the objects consistently regardless of who calls it.
    but this won't be the case if the caller is the subtype and other is the parent type, or vice versa. 
    there are 2 ways to fix this: 
    
    a) if you need to override compareTo() in a subclass, type check that other is also a subclass instance: 

        public int compareTo(Dog other) {
            if (getClass() != other.getClass()) throw new ClassCastException();
            ... 
        }

    b) use a single, final compareTo() method defined in the parent class


here are some programming techniques for using interfaces: 

    Animal animal = new Dog();                      // you can have variables whose type is an interface

    if (randomCreature instanceof Animal) {         // use instanceof to check for an objects conformance to an interface
        ... 
    }


    public interface Mammal extends Animal {        // you can create hierarchies of interfaces
        boolean WARMBLOODED = true;                 // properties are automatically public static final constant
    }                                               // here classes that implement this interface can refer to WARMBLOODED directly in their methods


while each class can only have 1 superclass, classes can have multiple interfaces.

    class Dog implements Mammal, Comparable {
        ...
    }


there are also sealed interfaces that work the same way as sealed classes:

    public sealed interface LargeMammal permits Dog, Moose, Bear, Human, Whale {
        ...
    }


Record and Enum classes can't extend other classes (they already extend the Record / Enum class),
    but they can implement interfaces.

you can have default implementations for interface methods, but they must be tagged with the default keyword:

    public interface Collection {
        int size();
        default bool isEmpty {
            return size() == 0;                 // default methods can call other interface methods
        }
    }

    public interface Comparable<T> {            // default methods can be useful in modifying an already public interface, 
        default int compareTo(T other) {        // classes using the interface won't have to recompile
            return 0;                           // this is important because JARs may not be recompiled before executing, 
        }                                       // causing runtime errors when the new interface method gets called
    }


if a class or superclass provides a method, any interface's default method with the same signature will be ignored 
    so you can never define an interface default method with the same signature as an Object method, since it's always ignored
if two interfaces you're conforming to define methods with the same signature, and one of them provides a default, 
    your class must provide its own implementation: 


    interface Person {
        default String getName() { return ""; }
    }

    interface Named {
        default String getName() { return getClass().getName() + "_" + hashCode(); }
    }

    class Student implements Person, Named {
        public String getName() {
            return Person.super.getName();                  // you can access the interfaces default implementation via this syntax
        }
    }


here's an example of how you'd change the default behavior of Comparator for a built-in class.
    in this case we sort strings by length instead of alphabetically:


    public interface Comparator<T> {                           // the Comparator interface defined in the standard library
        int compare(T first, T second);
    }
    __________________________________________
    // LengthComparator.java

    class LengthComparator implements Comparator<String> {
        public int comprae(String first, String second) {
            return first.length() - second.length();
        }
    }

    var string1 = "RAT";
    var string2 = "RAAAAAT";
    var customComparator = new LengthComparator();
    if (customComparator.compare(string1, string2) > 0) {       // compare() is called off the comparator object 
        ...                                                     // instead of the string itself
    }

    String[] friends = ["Paul", "John", "Ringo", "George"];
    Arrays.sort(friends, new LengthComparator());               // Arrays.sort takes a custom comparator as a parameter 


classes can conform to Clonable to implement a deep-clone method. 
    the default cloning operation inherited from Object is a shallow copy. 
        note that a shallow copy is fine if the shared state (the references that aren't deep-copied) is immutable or never mutated. 

by default instances can't be copied via calling clone(), because the default Object clone() method is protected, so can't be accessed from the outside. 
    to make it clonable from the outside the class must implement the Clonable interface, override the clone method to be public, and call super.clone()
        to do deep copying the class must also change the implementation of clone() 

if you try to clone an object that doesn't implement Clonable you'll throw an exception 


    class Dog implements Clonable {
        ... 

        public Dog clone() throws CloneNotSupportedException {
            return (Dog) super.clone();
        }
    }


    class Fish implements Clonable {
        FishTank tank = FishTank()

        public Fish clone() {                               // since we use try/catch and handle the error internally 
            try {                                           // we don't need to declare the exception in the signature - it won't propagate
                Fish clonedObj = (Fish) super.clone();
                clonedObj.fishTank = FishTank();
                return clonedObj;
            } catch CloneNotSupportedException {
                return null;
            }
        }
    }

be careful of parent classes implementing a public clone() method. if subclasses inherit this it could lead to incorrect cloning of your objects. 
    some people recommend avoiding the use of clone() because of this, it's only used in about 5% of the java standard library


lambda functions were added in Java 8. here's what the syntax looks like: 


    (String first, String second) -> {  
        return first.length() - second.length();
    }

    () -> {
        for (int x = 0; x < 100; x++) {
            System.out.println(x);
        }
    }


here's the String comparable we wrote earlier: 

    Comparator<String> comp = (first, second) -> { 
        first.length() - second.length();               // you never specify the result type of a lambad. it is always inferred from the context
    }


the compiler can infer first & second are Strings from the Comparable<String> type
    if the callback has a single parameter & its type is inferred you can even omit the parenthesis: 


    ActionListener listener = event -> { 
        System.out.println("time: " Instant.ofEpochMilli(event.getWhen()));
    }


you can use var to denote an inferred type, but this isn't common. this syntax was created for attaching annotations (see CH8 vol 2 for details):

    (@NonNull var first, @NonNull far second) -> first.length() - second.length()


it's illegal for a lambda to return a value in some branches but not others. 

in the past java didn't support callbcaks, and objects were passed in instead. many old interfaces still expect a callback-style object
    for this reason you can now supply a lambda in place of an object for an interface with a single abstract method.
        the runtime will automatically convert the lambda to an object that implements the interface. 
        interfaces like this are called functional interfaces. some examples where this can happen are Comparator and ActionListener
    

    Arrays.sort(friendNames, (first, second) -> {                   // the second parameter to this method is a Comparator. 
        first.length() - second.length();                           // the runtime is converting this lambda to a Comparator object behind the scenes
    });

    var timer = new Timer(1000, event -> {                                          // ActionListener is the functional interface used with Timer objects
        System.out.println("time is: " + Instant.ofEpochMilli(event.getWhen()));
    });


conversion to these functional interfaces is the only thing you can do with callbacks in Java.
    functional interfaces are the syntax for passing a callback to a method.   
    in other languages you can declare a variable or parameter with the functions signature as its type, but not in Java.

    however, you can assign lambdas to variables whose type is a functional interface.
        java.util.function defines alot of generic functional interfaces you can use. 
            BiFunction<T, U, R> is one such example - its abstract method has two generic parameters and one generic return type

    import java.util.function;

    BiFunction<String, String, Integer> comparator = (first, second) -> first.length() - second.length();


note that you still won't be able to pass a BiFunction to Arrays.sort(), since Arrays.sort() doesn't expect a BiFunction type
but some methods are compatible with java.util.function's generic functional interfaces. 
    Predicate is a useful generic functional interface that defines a single boolean method. methods like this can be used in boolean logic. 
        ArrayList has a remoteIf method that takes a Predicate.
    Supplier is another useful generic functional interface that defines a get() method.
        Supplier is used by LocalDate to implement lazy evaluation.


    // definitions in java.util.function;
    public interface Predicate<T> { 
        boolean test(T t);
    }
    public interface Supplier<T> {
        T get();
    }

    // your code 
    arrayList.removeIf(obj -> obj == null); 

    LocalDate hireDay = Objects.requireNonNullElse(     
        day, 
        LocalDate.of(1970, 1, 1)                        // takes a Supplier and waits to call it / construct the LocalDate object until it's necessary
    );
    

if your lambda will only wrap a single method call with the same signature, and nothing else, 
    you can pass that method directly instead of creating the lambda. this is called a method reference.
    like with lambdas, the runtime will convert this method to a functional interface object with a matching signature & pass it in: 


    var timer = new Timer(1000, event -> System.outprintln(event));

    var timer2 = new Timer(1000, System.out::println);                  // method reference 


notice the use of the scope resolution operator :: - this operator specifies a method reference. it can be used in 3 different formats: 

    object::instanceMethod              // with this syntax the lambdas arguments are mapped directly to the method
    super::instanceMethod               // it's also valid to use super in this form

    Class::instanceMethod               // the lambdas first argument will be the implicit parameter of the method (i.e. this), 
                                        // and subsequent arguments are mapped to the method
                                        // i.e. String::compareToIgnoreCase is the same as (x, y) -> x.compareToIgnoreCase(y)

    Class::staticMethod                 // again the lambdas arguments are mapped directly to the method


some parts of the standard library contain methods meant to be used as method references. 
    for example, by itself Objects.isNull(obj) doesn't appear to be useful. you could just write object == null instead.
    but you can use this as a method reference with a Predicate parameter:


    arrayList.removeIf(Objects::isNull); 


you can also use constructors as method references by passing new as the method name: 


    ArrayList<String> friendNames = new ArrayList<String>(4);
    ... 
    Stream<Person> stream = friendNames.stream().map(Person::new);
    List<Person> people = stream.toList();


you can also reference the constructors of arrays.
    i.e. int[]::new is a constructor reference with a parameter for the array length.


    Person[] people = stream.toArray(Person[]::new);        // this is a trick for getting an array of a generic type T
                                                            // normally toArray() would return an array of type Object here
                                                            // but the stream library added a version of toArray that takes a constructor reference 
                                                            // it can invoke this constructor to get an array of the correct type, then fill the array 

when you pass a lambda to a function interface, and the runtime translates it into an object,
    the variables captured in closure become properties of the new object. whether they're copied or references is an undefined and implementation detail
        but the closured properties are made immutable. you can't change them within the closure, so it doesn't matter.
        it's also illegal to reference a closured variable within the lambda if that variable is mutated in the parent scope
        without these restrictions there could be concurrency bugs if the closure is invoked asynchronously or is escaping
    in the lambdas scope you also can't create properties that have the same name as closure properties
    lambda expressions capture by closure the "this" pointer of their enclosing scope


here are the most common functional interfaces provided by the Java API. 
    usually you can find a functional interface that meets your needs, and won't need to create one: 


    Function Interface Name             Signature                   Description
    _______________________________________________________________________________________ 

    Runnable                            () -> Void                  runs code - no arguments or return value

    Supplier<T>                         () -> T                     gets a value of type T

    Consumer<T>                         (T) -> Void                 consumes a value of type T

    BiConsumer<T, U>                    (T, U) -> Void 

    Function<T, R>                      (T) -> R 

    BiFunction<T, U, R>                 (T, U) -> R 

    UnaryOperator<T>                    (T) -> T                    unary operatio nperformed on type T       

    BinaryOperator<T>                   (T, U) -> T

    Predicate<T>                        (T) -> boolean              boolean test on type T

    BiPredicate<T, U>                   (T, U) -> boolean


you may want to use function interfaces that aren't generic sometimes. 
    maybe because the interface should only accept a certain type of input. 
    specialized interfaces are also more efficient than generics.
    the standard library provides 34 specialized functional interfaces for primitive types. google for a list of what's available: 

    
    public interface IntConsumer {              // an existing interface provided by Java
        void accept(int value);
    }

    public void countDown(int total, IntConsumer action) {              // the closure should only pass an integer
        for (int x = total; x >= 0; x--) {
            action.accept(x);
        }
    }

    countDown(10, x -> System.out.println("Countdown: " + x));


if you design your own functional interface you can tag it with the @FunctionalInterface annotation.
    the compiler will then throw an error if someone accidentally adds another method
    the javadoc page will also now include a statement saying that your interface is a functional interface

the standard library also provides many default methods for these predefined functional interfaces.
    i.e. Predicate.isEqual(a) works correctly with null. google for more details.

the Comparator interface also has many static methods designed to work with method references / lambdas. 

    Person[] beatles = [
        Person("Paul McCartney"), 
        Person("John Lennon"), 
        Person("Ringo Star"), 
        Person("George Harrison")
    ];

    Arrays.sort(beatles, Comparator.comparing(Person::getFirstName));       // comparing() can take a method reference that gets a string 

    Arrays.sort(beatles, 
        Comparator.comparing(Person::getFirstName)
        .thenComparing(Person::getLastName)                                 // there's also a thenComparing() method that allows you to chain calls
    );

    Arrays.sort(beatles, 
        Comparator.comparing(Person::getFirstName, 
        (s, t) -> Integer.compare(s.length(), t.length())                   // you can also pass in a lambda for doing the comparison 
    ));

    Arrays.sort(beatles, 
        Comparator.comparingInt(p -> p.getFirstName.length())               // comparingInt() here does the same thing as the lambda, but more concisely
    );

    // nullsFirst() / nullsLast() can be used to modify a comparator so it doesn't throw if nulls are encountered, 
    // but instead ranks them smaller or larger than regular values.
    // but nullsFirst() / nullsLast themselves need a comaprator. 
    // naturalOrder() automatically makes a comparator for any class that implements Comparable.
    Arrays.sort(beatles,                                                    
        Comparator.comparing(Person::getMiddleName, Comparator.nullsFirst(Comparator.naturalOrder())) 
    );

    // reverseOrder() is an alternative to naturalOrder()
    Arrays.sort(beatles,                                                    
        Comparator.comparing(Person::getMiddleName, Comparator.nullsFirst(Comparator.reverseOrder())) 
    );

~~~~~~~~~~~~~~~~~~~~~~~~
skipping the rest of the chapter for now - sections 6.3 - 6.5

______________________________________________________________________________________________________________________
CHAPTER 7: EXCEPTIONS, ASSERTIONS, AND LOGGING 

skipped for now

______________________________________________________________________________________________________________________
CHAPTER 8: GENERIC PROGRAMMING 

pg 447






