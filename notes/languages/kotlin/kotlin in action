
this book covers kotlin 1.0 and was released in 2017

========================================================
CHAPTER 1: KOTLIN - WHAT AND WHY 
========================================================

kotlin and its compiler / related libraries / tooling are open source. 

these 2 IDEs are typically used with kotlin:  
    IntelliJ IDEA
    Android Studio -  based on IntelliJ IDEA, but specializes in developing for Android 

the kotlin plugin for IntelliJ IDEA / Android Studio was developed alongside the kotlin compiler
    this plugin is included out of the box with these IDEs 

interoperability with Java was a cornerstone of kotlins design 
    kotlin can be used anywhere Java is used, and works with all existing Java libraries / frameworks 
        so like Java, kotlin is mainly used in server-side programming and Android development
    you can use kotlin in an existing Java codebase as well
        you can even extend existing java classes with kotlin or annotate java methods & fields in certain ways

there are followup efforts to make kotlin compile to javascript or to native code 
there's an intel multi-OS engine that can be used to run kotlin on iOS devices (probably won't work on apple silicon though)
you can also use kotlin with TornadoFX to build desktop applications

kotlin is statically typed

in declarations you aren't required to specify a type if the type can be inferred: 

    val x = 2               // inferred to be an Int 


kotlin handles null values in a way that's similr to swift 
kotlin also has built in support for function types, unlike Java 

kotlin supports functional programming. these are apparently the key concepts of functional programming: 

    1) functions are first class objects, so they can be passed as parameters, stored in variables, and returned 
    2) the objects you work with are immutable 
    3) functions do not have side effects. for example, they work with a copy of the data, and won't modify the state of objects 

    these features allow for safe multithreading 


kotlins key features for supporting functional programming are: 

    1) function types
    2) lambdas 
    3) data classes - a concise syntax for creating immutable value objects 


there's a special kotlin compiler-plugin for supporting the Android framework. 
    there's also an Anko library (built by the kotlin team) which adds alot of kotlin adapters for many standard Android APIs

kotlin's design makes runtime errors less of a problem. 
    for example, its handling of null values makes NullPointerException not a problem 

alot of boilerplate in Java (like getters / setters) is implicit in kotlin. this makes the language more concise 

kotlin reuses java libraries as much as possible. it extends javas standard library to make it easy to use with kotlin.

kotlin source files end in the .kt extension. the kotlin compiler generates .class files from these:

    kotlinc file.kt -include-runtime -d jarName         // compile a kotlin file to a JAR
    java -jar jarName                                   // now execute the JAR file 


if you run kotlinc with no arguments it'll launch the kotlin interactive shell
    they call this shell the REPL 

code compiled using kotlinc (the kotlin compiler) depends on the kotlin runtime library.
    this contains the definitions of kotlin's own standard library classes and the extensions kotlin adds to the standard Java APIs 
    this runtime library needs to be distributed with your application (hence the JAR?)

typically people use Maven, Gradle, or Ant to build instead of doing it manually 
    all these build systems do support building mixed projects of Java & Kotlin 
    Maven and Gradle will also take care of including the kotlin runtime library 

IntelliJ IDEA has a Java to kotlin converter built in. 
    if you paste Java code into a kotlin file it will do this conversion automatically.
    you can also open a java file and select Code > Convert Java File to Kotlin File 

========================================================
CHAPTER 2: KOTLIN BASICS
========================================================

the main function can be declared at the top level - you don't need to put it in a class as in Java: 

    fun main(args: Array<String>) {
        println("Hello World!")                         // println instead of System.out.println
    }                                                   // the kotlin standard library provides many wrappers around Javas standard library methods 


the semi-colon at the end of lines is optional 

use a colon to denote a functions return value: 

    fun max(a: Int, b: Int): Int {
        return if (a > b) a else b 
    } 


if/else has a return value and works similar to the ternary operator.
    in kotlin most control structures (except for the various loops) are expressions that return a value. 
    but assignment statements are not expressions and don't return a value (unlike in Java)

if a function consists of a single expression you can omit the curly braces and return statement: 

    fun max(a: Int, b: Int): Int = if (a > b) a else b


infact, for these single expression functions you can even omit the return type, since kotlin can infer it. I think I'd rather include it anyway though:

    fun max(a: Int, b: Int) = if (a > b) a else b


variable declaration is almost the same as Swift. only difference is val is the immutable reference instead of let. var is again mutable:

    val num1 = 1                            // if the type can be inferred it can be omitted
    val num2: Int = 2

    val num3: Int                           // an immutable val must be initialized within the block inwhich its defined 
    if (num1 > 0) {                         // but you can use branching logic to initialize it 
        num3 = 3
    } else {
        num3 = 4
    }


string interpolation is done using the $ character: 

    val name = "Ian"
    println("hello, $name")


to interpolate a property of an object or an expression (more than just a simple variable name) you must use ${} like this: 

    fun main(args: Array<String>) {
        if (args.size > 0) {
            println("first argument is ${args[0]}) 
        } 
    }


the ${} syntax is also useful for interpolating double quotes into the string: 

    println("hello ${if (args.size > 0) args[0] else "someone"}")


backslash \ is the escape character: 

    println("your total is \$0.00")                         // you must escape the $ character to use it in a string
    

in kotlin there's a more concise syntax for classes.
    the following two classes are identical. understanding this allows you to use a kotlin class from java & vice versa: 

    // java version 
    public class Dog {
        private final String name; 
        private final Int pounds;

        public Dog(String name, Int pounds) {
            this.name = name;
            this.pounds = pounds;
        }

        public String getName() {
            return name;
        }
        public String getPounds() {
            return pounds;
        }
        public setPounds(Int newPounds) {
            this.pounds = newPounds;
        }
    }

    // calling java from kotlin 
    val dog = Dog("Dawg", 65)

    println(dog.name)                       // javas basic getters are accessed via the property name directly
    println(dog.pounds)
    dog.pounds = 67

    ___________________________________________________

    // kotlin version 
    class Dog(val name: String, var pounds: Int) 


    // calling kotlin from java 
    Dog dog = new Dog("Dawg", 65);

    System.out.println(dog.getName());                  // these getters are automatically synthesized
    System.out.println(dog.getPounds());


classes such as the above, which only contain data and no code, are often called data classes

notice there's no public keyword in the kotlin version - in kotlin public is the default visibility (weird) 

in java fields are usually private and getters/setters are used for access (though this isn't mandatory) 
    in kotlin when you declare a class property its getter/setter is automatically synthesized.
        a val property only has a getter synthesized; a var property has both a getter & setter synthesized

    the synthesized getters typically are prefixed by "get".
        there is one exception though - if the property name starts with "is". 
            in this case no additional prefix is added to the getter, and in the setter name "is" is replaced with "set" 
            similarly if a java class defines a getter that begins with "is" the kotlin code will have a corresponding property beginning with "is" 


computed properties in kotlin are implemented using custom getters / setters which don't reference a stored property: 

    class Rectangle(val height: Int, val width: Int) {
        val isSquare: Boolean 
            get() {
                return height == width
            }
    }

    class Rectangle(val height: Int, val width: Int) {
        val isSquare: Boolean 
            get() = height == width                     // more concise syntax
    }


    // accessed from kotlin 
    val rect = Rectangle(10, 12)
    println(rect.isSquare)

    // accessed from Java
    Rectangle rect = Rectangle(10, 12);
    System.out.println(rect.isSquare());


like java, kotlin organizes its code into packages. 
    kotlin files can have a package statement at the beginning, 
        and all classes / functions / properties defined in that file will be put into the package
        kotlin doesn't distinguishes between importing classes and functions - you can import either 
    declarations in the same package can be used without import, otherwise they must be imported
    import statements are also placed at the beginning of the file 


    package geometry.shapes 

    import java.util.Random 

    class Rectangle(val height: Int, val width: Int) {
        val isSquare: Boolean 
            get() = height == width
    }

    fun createRandomRect(): Rectangle {
        val random = Random()
        return Rectangle(random.nextInt(), random.nextInt())
    }

    _______________________
    
    package geometry.example 

    import geometry.shapes.createRandomRect 

    func main(args: Array<String>) {
        let rect = createRandomRect()
        println("width: ${rect.width}, height: ${rect.height}, isSquare: ${rect.isSquare}")
    }


you can import all declarations in a package using *

    import geometry.shapes.* 


in java the package structure must match the file/directory structure.
    for example, lets say you have a package {geometry.shapes} that contains multiple classes.
    each class must be in a separate file with a matching name: 

    geometry/ 
        example/
            Main
        shapes/                         // geometry.shapes 
            Rectangle
            Circle


in kotlin you can put multiple classes in the same file, the class name need not match the file name. this allows you to flatten the directory structure:

    geometry/
        example.kt
        shapes.kt                       // no need for a seperate shapes folder - everything in geometry.shapes can go directly in this file 


for consistency and organization it's still generally good to follow Javas directory layout principles, especially if you're mixing Java & Kotlin code. 
    the ability to put multiple classes into one kotlin file can help keep the directory structure simpler, though.
    

the enum keyword in kotlin is context aware.
    if it precedes the class keyword it indicates an enum class declaration.
    otherwise enum is not reserved and can be used like any other word.

    enum class Color {
        RED, ORANGE, YELLOW, GREEN, BLUE, INDIGO, VIOLET
    }


enums can be have properties and methods:

    enum class Color(val r: Int, val g: Int, val b: Int) {
        RED(255, 0, 0),
        ORANGE(255, 165, 0),                        // these are the values passed into the constructor for this case
        YELLOW(255, 255, 0),
        GREEN(0, 255, 0),
        BLUE(0, 0, 255),
        INDIGO(75, 0, 130),
        VIOLET(238, 130, 238);                      // you must include this semi-colon at the end of the case declarations
                                                    // if your enum will contain methods
        fun rgb() = (r * 256 + g) * 256 + b
    }

    println(Color.BLUE.rgb())


when is kotlins version of a switch statement, but it returns a value and is more powerful:

    fun getColorName(color: Color) =
        when(color) {
            Color.RED -> "Red"
            Color.ORANGE -> "Orange"                    // you don't need break statements in a when expression, unlike in Javas old switch
            Color.YELLOW -> "Yellow"
            Color.GREEN -> "Green"
            Color.BLUE -> "Blue"
            Color.INDIGO -> "Indigo"
            Color.VIOLET -> "Violet"
        }


if you import the enum you don't have to precede the cases with the enum name:

    import dataModels.Color                 // imports the Color class declared in another package
    import dataModels.Color.*               // explicitly imports enum constants to use them by name

    fun getColorWarmth(color: Color) =
        when(color) {
            RED, ORANGE, YELLOW -> "warm"                   // notice you can combine multiple cases in one branch, like in swift
            GREEN -> "neutral"
            BLUE, INDIGO, VIOLET -> "cold"
        }


kotlin's when can switch off any object, unlike Java's switch:

    fun mix(color1: Color, color2: Color) =
        when (setOf(color1, color2)) {
            setOf(RED, YELLOW) -> ORANGE                    // setOf() is the kotlin library function for creating a Set
            setOf(YELLOW, BLUE) -> GREEN                    // Sets are nice for comparison here because ordering doesn't matter
            setOf(BLUE, VIOLET) -> INDIGO
            else -> throw Exception("dirty color")
        }


you can also use when without an argument and just do direct reference comparisons in it:

    // avoids creatinga a bunch of sets that will require garbage collection later
    fun mixOptimized(color1: Color, color2: Color) =
        when {
            (color1 == RED && color2 == YELLOW) || (color2 == RED && color1 == YELLOW) -> ORANGE
            (color1 == BLUE && color2 == YELLOW) || (color2 == BLUE && color1 == YELLOW) -> GREEN
            (color1 == BLUE && color2 == VIOLET) || (color2 == BLUE && color1 == VIOLET) -> INDIGO
            else -> throw Exception("dirty color")
        }

typecasting in Java is a 2 step process:
    1) do type-checking via instanceOf()
    2) followup with explicit type-casting and assign the result to a new variable

kotlins 'is' operator can do smart casting, which combines both the type-checking and type-casting in one operation.

    interface Expression
    class Num(val value: Int) : Expression
    class Sum(val left: Expression, val right: Expression) : Expression

    func doAlgebraicAddition(e: Expression): Int =
        if (e is Num) {                                             // here e is both type-checked and type-cast in one operation
            e.value                                                 // so you can access properties of Num on the next line
        } else if (e is Sum) {                                      // the compiler achieves this by ensuring e hasn't changed since the operation
            doAlgebraicAddition(e.right) + doAlgebraicAddition(e.left)
        } else {
            throw IllegalArgumentException("unknown expression")
        }


    println(doAlgebraicAddition(Sum(Num(1), Num(2))))


the return value of a block is the last statement in it.
    this is true anywhere a block is used and a result is expected, except for in regular functions (so... if, when, try/catch, lambdas)
also, you can omit the curly braces for a block if it only takes up one line

you can combine 'when' and 'is' for even more concise type-checking / casting:

    func doAlgebraicAddition(e: Expression): Int =
        when (e) {
            is Num -> {                                 // when cases can have blocks in curly braces. you still precede them with an arrow
                println("found an actual number")
                e.value
            }
            is Sum ->
                doAlgebraicAddition(e.right) + doAlgebraicAddition(e.left)
            else ->
                throw IllegalArgumentException("unknown expression")
        }


looping is generally very similar to other languages:

    while(true) {
        ...
    }

    do {
        ...
    } while(true)


kotlin can use ranges to loop over things, similar to python:

    val oneToTen = 1..10                // ranges can be created with the .. operator
                                        // ranges are inclusive - 10 is part of this range
    for (x in oneToTen) {
        ...
    }

    for (x in 100 downTo 1 step 2) {    // another syntax for creating a range. this time we count down by 2s though
        ...
    }

    for (x in 1 until 10) {             // the until keyword can be used to create a non-inclusive range. this range will not include 10
        ...
    }

    for (letter in 'a'..'z') {          // ranges can be between characters
        println(letter)
    }


you can loop over more complex collections like trees:

    val letterToNumber = TreeMap<Char, Int>()

    for (letter in 'a'..'z') {
        val num = letter.toInt()
        letterToNumber[letter] = num
    }

    for ((letter, num) in letterToNumber) {
        println("$letter = $num")
    }


collections also have a convenient withIndex() method you can use to get the elements index along with the element:

    val listOfNames = arrayListOf("john", "paul", "george", "ringo")
    for ((index, name) in listOfNames.withIndex()) {
        println("beatle number $index: $name")
    }


pg 38, 2.4.4 










