
this book covers kotlin 1.0 and was released in 2017

========================================================
CHAPTER 1: KOTLIN - WHAT AND WHY 
========================================================

kotlin and its compiler / related libraries / tooling are open source. 

these 2 IDEs are typically used with kotlin:  
    IntelliJ IDEA
    Android Studio -  based on IntelliJ IDEA, but specializes in developing for Android 

the kotlin plugin for IntelliJ IDEA / Android Studio was developed alongside the kotlin compiler
    this plugin is included out of the box with these IDEs 

interoperability with Java was a cornerstone of kotlins design 
    kotlin can be used anywhere Java is used, and works with all existing Java libraries / frameworks 
        so like Java, kotlin is mainly used in server-side programming and Android development
            server-side programming is a broad category, but roughly includes web servers, mobile app servers, and microservices
    you can use kotlin in an existing Java codebase as well
        you can even extend existing java classes with kotlin or annotate java methods & fields in certain ways

there are followup efforts to make kotlin compile to javascript or to native code 
there's an intel multi-OS engine that can be used to run kotlin on iOS devices (probably won't work on apple silicon though)
you can also use kotlin with TornadoFX to build desktop applications

kotlin is statically typed

in declarations you aren't required to specify a type if the type can be inferred: 

    val x = 2               // inferred to be an Int 


kotlin handles null values in a way that's similr to swift 
kotlin also has built in support for function types, unlike Java 

kotlin supports functional programming. these are apparently the key concepts of functional programming: 

    1) functions are first class objects, so they can be passed as parameters, stored in variables, and returned 
    2) the objects you work with are immutable 
    3) functions do not have side effects. for example, they work with a copy of the data, and won't modify the state of objects 

    these features allow for safe multithreading 


kotlins key features for supporting functional programming are: 

    1) function types
    2) lambdas 
    3) data classes - a concise syntax for creating immutable value objects 


there's a special kotlin compiler-plugin for supporting the Android framework. 
    there's also an Anko library (built by the kotlin team) which adds alot of kotlin adapters for many standard Android APIs

kotlin's design makes runtime errors less of a problem. 
    for example, its handling of null values makes NullPointerException not a problem 

alot of boilerplate in Java (like getters / setters) is implicit in kotlin. this makes the language more concise 

kotlin reuses java libraries as much as possible. it extends javas standard library to make it easy to use with kotlin.

kotlin source files end in the .kt extension. the kotlin compiler generates .class files from these:

    kotlinc file.kt -include-runtime -d jarName         // compile a kotlin file to a JAR
    java -jar jarName                                   // now execute the JAR file 


if you run kotlinc with no arguments it'll launch the kotlin interactive shell
    they call this shell the REPL 

code compiled using kotlinc (the kotlin compiler) depends on the kotlin runtime library.
    this contains the definitions of kotlin's own standard library classes and the extensions kotlin adds to the standard Java APIs 
    this runtime library needs to be distributed with your application (hence the JAR?)

typically people use Maven, Gradle, or Ant to build instead of doing it manually 
    all these build systems do support building mixed projects of Java & Kotlin 
    Maven and Gradle will also take care of including the kotlin runtime library 

IntelliJ IDEA has a Java to kotlin converter built in. 
    if you paste Java code into a kotlin file it will do this conversion automatically.
    you can also open a java file and select Code > Convert Java File to Kotlin File 

========================================================
CHAPTER 2: KOTLIN BASICS
========================================================

the main function can be declared at the top level - you don't need to put it in a class as in Java: 

    fun main(args: Array<String>) {
        println("Hello World!")                         // println instead of System.out.println
    }                                                   // the kotlin standard library provides many wrappers around Javas standard library methods 


the semi-colon at the end of lines is optional 

use a colon to denote a functions return value: 

    fun max(a: Int, b: Int): Int {
        return if (a > b) a else b 
    } 


in the above code the if/else has a return value, and works similar to the ternary operator.
    in kotlin most control structures (except for the various loops) are expressions that return a value. 
    but assignment statements are not expressions and don't return a value (unlike in Java)

if a function consists of a single expression you can omit the curly braces and return statement: 

    fun max(a: Int, b: Int): Int = if (a > b) a else b


infact, for these single expression functions you can even omit the return type, since kotlin can infer it. I think I'd rather include it anyway though:

    fun max(a: Int, b: Int) = if (a > b) a else b


variation declaration is almost the same as Swift. only difference is val is the immutable reference instead of let. var is again mutable: 

    val num1 = 1                            // if the type can be inferred it can be omitted
    val num2: Int = 2

    val num3: Int                           // an immutable val must be initialized within the block inwhich its defined 
    if (num1 > 0) {                         // but you can use branching logic to initialize it 
        num2 = 3
    } else {
        num2 = 4
    }


string interpolation is done using the $ character: 

    val name = "Ian"
    println("hello, $name")


to interpolate a property of an object or an expression (more than just a simple variable name) you must use ${} like this: 

    fun main(args: Array<String>) {
        if (args.size > 0) {
            println("first argument is ${args[0]}) 
        } 
    }


the ${} syntax is also useful for interpolating double quotes into the string: 

    println("hello ${if (args.size > 0) args[0] else "someone"}")


backslash \ is the escape character: 

    println("your total is \$0.00")                         // you must escape the $ character to use it in a string
    


in kotlin there's a more concise syntax for classes.
    the following two classes are identical. understanding this allows you to use a kotlin class from java & vice versa: 

    // java version 
    public class Dog {
        private final String name; 
        private final Int pounds;

        public Dog(String name, Int pounds) {
            this.name = name;
            this.pounds = pounds;
        }

        public String getName() {
            return name;
        }
        public String getPounds() {
            return pounds;
        }
        public setPounds(Int newPounds) {
            this.pounds = newPounds;
        }
    }

    // calling java from kotlin 
    val dog = Dog("Dawg", 65)

    println(dog.name)                       // javas basic getters are accessed via the property name directly
    println(dog.pounds)
    dog.pounds = 67

    ___________________________________________________

    // kotlin version 
    class Dog(val name: String, var pounds: Int) 


    // calling kotlin from java 
    Dog dog = new Dog("Dawg", 65);

    System.out.println(dog.getName());                  // these getters are automatically synthesized
    System.out.println(dog.getPounds());


classes such as the above, which only contain data and no code, are often called data classes

notice there's no public keyword in the kotlin version - in kotlin public is the default visibility (weird) 

in java fields are usually private and getters/setters are used for access (though this isn't mandatory) 
    in kotlin when you declare a class property its getter/setter is automatically synthesized.
        a val property only has a getter synthesized; a var property has both a getter & setter synthesized

    the synthesized getters typically are prefixed by "get".
        there is one exception though - if the property name starts with "is". 
            in this case no additional prefix is added to the getter, and in the setter name "is" is replaced with "set" 
            similarly if a java class defines a getter that begins with "is" the kotlin code will have a corresponding property beginning with "is" 


computed properties in kotlin are implemented using custom getters / setters which don't reference a stored property: 

    class Rectangle(val height: Int, val width: Int) {
        val isSquare: Boolean 
            get() {
                return height == width
            }
    }

    class Rectangle(val height: Int, val width: Int) {
        val isSquare: Boolean 
            get() = height == width                     // more concise syntax
    }


    // accessed from kotlin 
    val rect = Rectangle(10, 12)
    println(rect.isSquare)

    // accessed from Java
    Rectangle rect = Rectangle(10, 12);
    System.out.println(rect.isSquare());


like java, kotlin organizes its code into packages. 
    kotlin files can have a package statement at the beginning, 
        and all classes / functions / properties defined in that file will be put into the package
        kotlin doesn't distinguishes between importing classes and functions - you can import either 
    declarations in the same package can be used without import, otherwise they must be imported
    import statements are also placed at the beginning of the file 


    package geometry.shapes 

    import java.util.Random 

    class Rectangle(val height: Int, val width: Int) {
        val isSquare: Boolean 
            get() = height == width
    }

    fun createRandomRect(): Rectangle {
        val random = Random()
        return Rectangle(random.nextInt(), random.nextInt())
    }

    _______________________
    
    package geometry.example 

    import geometry.shapes.createRandomRect 

    func main(args: Array<String>) {
        let rect = createRandomRect()
        println("width: ${rect.width}, height: ${rect.height}, isSquare: ${rect.isSquare}")
    }


you can import all declarations in a package using *

    import geometry.shapes.* 


in java the package structure must match the file/directory structure.
    for example, lets say you have a package {geometry.shapes} that contains multiple classes.
    each class must be in a separate file with a matching name: 

    geometry/ 
        example/
            Main
        shapes/                         // geometry.shapes 
            Rectangle
            Circle


in kotlin you can put multiple classes in the same file, the class name need not match the file name. this allows you to flatten the directory structure:

    geometry/
        example.kt
        shapes.kt                       // no need for a seperate shapes folder - everything in geometry.shapes can go directly in this file 


for consistency and organization it's still generally good to follow Javas directory layout principles, especially if you're mixing Java & Kotlin code. 
    the ability to put multiple classes into one kotlin file can help keep the directory structure simpler, though.
    


pg 28, 2.3















