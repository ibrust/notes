
this book covers kotlin 1.0 and was released in 2017

========================================================
CHAPTER 1: KOTLIN - WHAT AND WHY 
========================================================

kotlin and its compiler / related libraries / tooling are open source. 

these 2 IDEs are typically used with kotlin:  
    IntelliJ IDEA
    Android Studio -  based on IntelliJ IDEA, but specializes in developing for Android 

the kotlin plugin for IntelliJ IDEA / Android Studio was developed alongside the kotlin compiler
    this plugin is included out of the box with these IDEs 

interoperability with Java was a cornerstone of kotlins design 
    kotlin can be used anywhere Java is used, and works with all existing Java libraries / frameworks 
        so like Java, kotlin is mainly used in server-side programming and Android development
    you can use kotlin in an existing Java codebase as well
        you can even extend existing java classes with kotlin or annotate java methods & fields in certain ways

there are followup efforts to make kotlin compile to javascript or to native code 
there's an intel multi-OS engine that can be used to run kotlin on iOS devices (probably won't work on apple silicon though)
you can also use kotlin with TornadoFX to build desktop applications

kotlin is statically typed

in declarations you aren't required to specify a type if the type can be inferred: 

    val x = 2               // inferred to be an Int 


kotlin handles null values in a way that's similr to swift 
kotlin also has built in support for function types, unlike Java 

kotlin supports functional programming. these are apparently the key concepts of functional programming: 

    1) functions are first class objects, so they can be passed as parameters, stored in variables, and returned 
    2) the objects you work with are immutable 
    3) functions do not have side effects. for example, they work with a copy of the data, and won't modify the state of objects 

    these features allow for safe multithreading 


kotlins key features for supporting functional programming are: 

    1) function types
    2) lambdas 
    3) data classes - a concise syntax for creating immutable value objects 


there's a special kotlin compiler-plugin for supporting the Android framework. 
    there's also an Anko library (built by the kotlin team) which adds alot of kotlin adapters for many standard Android APIs

kotlin's design makes runtime errors less of a problem. 
    for example, its handling of null values makes NullPointerException not a problem 

alot of boilerplate in Java (like getters / setters) is implicit in kotlin. this makes the language more concise 

kotlin reuses java libraries as much as possible. it extends javas standard library to make it easy to use with kotlin.

kotlin source files end in the .kt extension. the kotlin compiler generates .class files from these:

    kotlinc file.kt -include-runtime -d jarName         // compile a kotlin file to a JAR
    java -jar jarName                                   // now execute the JAR file 


if you run kotlinc with no arguments it'll launch the kotlin interactive shell
    they call this shell the REPL 

code compiled using kotlinc (the kotlin compiler) depends on the kotlin runtime library.
    this contains the definitions of kotlin's own standard library classes and the extensions kotlin adds to the standard Java APIs 
    this runtime library needs to be distributed with your application (hence the JAR?)

typically people use Maven, Gradle, or Ant to build instead of doing it manually 
    all these build systems do support building mixed projects of Java & Kotlin 
    Maven and Gradle will also take care of including the kotlin runtime library 

IntelliJ IDEA has a Java to kotlin converter built in. 
    if you paste Java code into a kotlin file it will do this conversion automatically.
    you can also open a java file and select Code > Convert Java File to Kotlin File 

========================================================
CHAPTER 2: KOTLIN BASICS
========================================================

the main function can be declared at the top level - you don't need to put it in a class as in Java: 

    fun main(args: Array<String>) {
        println("Hello World!")                         // println instead of System.out.println
    }                                                   // the kotlin standard library provides many wrappers around Javas standard library methods 


the semi-colon at the end of lines is optional 

use a colon to denote a functions return value: 

    fun max(a: Int, b: Int): Int {
        return if (a > b) a else b 
    } 


if/else has a return value and works similar to the ternary operator.
    in kotlin most control structures (except for the various loops) are expressions that return a value. 
    but assignment statements are not expressions and don't return a value (unlike in Java)

if a function consists of a single expression you can omit the curly braces and return statement: 

    fun max(a: Int, b: Int): Int = if (a > b) a else b


infact, for these single expression functions you can even omit the return type, since kotlin can infer it. I think I'd rather include it anyway though:

    fun max(a: Int, b: Int) = if (a > b) a else b


variable declaration is almost the same as Swift. only difference is val is the immutable reference instead of let. var is again mutable:

    val num1 = 1                            // if the type can be inferred it can be omitted
    val num2: Int = 2

    val num3: Int                           // an immutable val must be initialized within the block inwhich its defined 
    if (num1 > 0) {                         // but you can use branching logic to initialize it 
        num3 = 3
    } else {
        num3 = 4
    }


string interpolation is done using the $ character: 

    val name = "Ian"
    println("hello, $name")


to interpolate a property of an object or an expression (more than just a simple variable name) you must use ${} like this: 

    fun main(args: Array<String>) {
        if (args.size > 0) {
            println("first argument is ${args[0]}) 
        } 
    }


the ${} syntax is also useful for interpolating double quotes into the string: 

    println("hello ${if (args.size > 0) args[0] else "someone"}")


backslash \ is the escape character: 

    println("your total is \$0.00")                         // you must escape the $ character to use it in a string
    

in kotlin there's a more concise syntax for classes.
    the following two classes are identical. understanding this allows you to use a kotlin class from java & vice versa: 

    // java version 
    public class Dog {
        private final String name; 
        private final Int pounds;

        public Dog(String name, Int pounds) {
            this.name = name;
            this.pounds = pounds;
        }

        public String getName() {
            return name;
        }
        public String getPounds() {
            return pounds;
        }
        public setPounds(Int newPounds) {
            this.pounds = newPounds;
        }
    }

    // calling java from kotlin 
    val dog = Dog("Dawg", 65)

    println(dog.name)                       // javas basic getters are accessed via the property name directly
    println(dog.pounds)
    dog.pounds = 67

    ___________________________________________________

    // kotlin version 
    class Dog(val name: String, var pounds: Int) 


    // calling kotlin from java 
    Dog dog = new Dog("Dawg", 65);

    System.out.println(dog.getName());                  // these getters are automatically synthesized
    System.out.println(dog.getPounds());


classes such as the above, which only contain data and no code, are often called data classes

notice there's no public keyword in the kotlin version - in kotlin public is the default visibility (weird) 

in java fields are usually private and getters/setters are used for access (though this isn't mandatory) 
    in kotlin when you declare a class property its getter/setter is automatically synthesized.
        a val property only has a getter synthesized; a var property has both a getter & setter synthesized

    the synthesized getters typically are prefixed by "get".
        there is one exception though - if the property name starts with "is". 
            in this case no additional prefix is added to the getter, and in the setter name "is" is replaced with "set" 
            similarly if a java class defines a getter that begins with "is" the kotlin code will have a corresponding property beginning with "is" 


computed properties in kotlin are implemented using custom getters / setters which don't reference a stored property: 

    class Rectangle(val height: Int, val width: Int) {
        val isSquare: Boolean 
            get() {
                return height == width
            }
    }

    class Rectangle(val height: Int, val width: Int) {
        val isSquare: Boolean 
            get() = height == width                     // more concise syntax
    }


    // accessed from kotlin 
    val rect = Rectangle(10, 12)
    println(rect.isSquare)

    // accessed from Java
    Rectangle rect = Rectangle(10, 12);
    System.out.println(rect.isSquare());


like java, kotlin organizes its code into packages. 
    kotlin files can have a package statement at the beginning, 
        and all classes / functions / properties defined in that file will be put into the package
        kotlin doesn't distinguishes between importing classes and functions - you can import either 
    declarations in the same package can be used without import, otherwise they must be imported
    import statements are also placed at the beginning of the file 


    package geometry.shapes 

    import java.util.Random 

    class Rectangle(val height: Int, val width: Int) {
        val isSquare: Boolean 
            get() = height == width
    }

    fun createRandomRect(): Rectangle {
        val random = Random()
        return Rectangle(random.nextInt(), random.nextInt())
    }

    _______________________
    
    package geometry.example 

    import geometry.shapes.createRandomRect 

    fun main(args: Array<String>) {
        let rect = createRandomRect()
        println("width: ${rect.width}, height: ${rect.height}, isSquare: ${rect.isSquare}")
    }


you can import all declarations in a package using *

    import geometry.shapes.* 


in java the package structure must match the file/directory structure.
    for example, lets say you have a package {geometry.shapes} that contains multiple classes.
    each class must be in a separate file with a matching name: 

    geometry/ 
        example/
            Main
        shapes/                         // geometry.shapes 
            Rectangle
            Circle


in kotlin you can put multiple classes in the same file, the class name need not match the file name. this allows you to flatten the directory structure:

    geometry/
        example.kt
        shapes.kt                       // no need for a seperate shapes folder - everything in geometry.shapes can go directly in this file 


for consistency and organization it's still generally good to follow Javas directory layout principles, especially if you're mixing Java & Kotlin code. 
    the ability to put multiple classes into one kotlin file can help keep the directory structure simpler, though.
    

the enum keyword in kotlin is context aware.
    if it precedes the class keyword it indicates an enum class declaration.
    otherwise enum is not reserved and can be used like any other word.

    enum class Color {
        RED, ORANGE, YELLOW, GREEN, BLUE, INDIGO, VIOLET
    }


enums can be have properties and methods:

    enum class Color(val r: Int, val g: Int, val b: Int) {
        RED(255, 0, 0),
        ORANGE(255, 165, 0),                        // these are the values passed into the constructor for this case
        YELLOW(255, 255, 0),
        GREEN(0, 255, 0),
        BLUE(0, 0, 255),
        INDIGO(75, 0, 130),
        VIOLET(238, 130, 238);                      // you must include this semi-colon at the end of the case declarations
                                                    // if your enum will contain methods
        fun rgb() = (r * 256 + g) * 256 + b
    }

    println(Color.BLUE.rgb())


when is kotlins version of a switch statement, but it returns a value and is more powerful:

    fun getColorName(color: Color) =
        when(color) {
            Color.RED -> "Red"
            Color.ORANGE -> "Orange"                    // you don't need break statements in a when expression, unlike in Javas old switch
            Color.YELLOW -> "Yellow"
            Color.GREEN -> "Green"
            Color.BLUE -> "Blue"
            Color.INDIGO -> "Indigo"
            Color.VIOLET -> "Violet"
        }


if you import the enum you don't have to precede the cases with the enum name:

    import dataModels.Color                 // imports the Color class declared in another package
    import dataModels.Color.*               // explicitly imports enum constants to use them by name

    fun getColorWarmth(color: Color) =
        when(color) {
            RED, ORANGE, YELLOW -> "warm"                   // notice you can combine multiple cases in one branch, like in swift
            GREEN -> "neutral"
            BLUE, INDIGO, VIOLET -> "cold"
        }


kotlin's when can switch off any object, unlike Java's switch:

    fun mix(color1: Color, color2: Color) =
        when (setOf(color1, color2)) {
            setOf(RED, YELLOW) -> ORANGE                    // setOf() is the kotlin library function for creating a Set
            setOf(YELLOW, BLUE) -> GREEN                    // Sets are nice for comparison here because ordering doesn't matter
            setOf(BLUE, VIOLET) -> INDIGO
            else -> throw Exception("dirty color")
        }


you can also use when without an argument and just do direct reference comparisons in it:

    // avoids creatinga a bunch of sets that will require garbage collection later
    fun mixOptimized(color1: Color, color2: Color) =
        when {
            (color1 == RED && color2 == YELLOW) || (color2 == RED && color1 == YELLOW) -> ORANGE
            (color1 == BLUE && color2 == YELLOW) || (color2 == BLUE && color1 == YELLOW) -> GREEN
            (color1 == BLUE && color2 == VIOLET) || (color2 == BLUE && color1 == VIOLET) -> INDIGO
            else -> throw Exception("dirty color")
        }

typecasting in Java is a 2 step process:
    1) do type-checking via instanceOf()
    2) followup with explicit type-casting and assign the result to a new variable

kotlins 'is' operator can do smart casting, which combines both the type-checking and type-casting in one operation.

    interface Expression
    class Num(val value: Int) : Expression
    class Sum(val left: Expression, val right: Expression) : Expression

    fun doAlgebraicAddition(e: Expression): Int =
        if (e is Num) {                                             // here e is both type-checked and type-cast in one operation
            e.value                                                 // so you can access properties of Num on the next line
        } else if (e is Sum) {                                      // the compiler achieves this by ensuring e hasn't changed since the operation
            doAlgebraicAddition(e.right) + doAlgebraicAddition(e.left)
        } else {
            throw IllegalArgumentException("unknown expression")
        }


    println(doAlgebraicAddition(Sum(Num(1), Num(2))))


the return value of a block is the last statement in it.
    this is true anywhere a block is used and a result is expected, except for in regular functions (so... if, when, try/catch, lambdas)
also, you can omit the curly braces for a block if it only takes up one line

you can combine 'when' and 'is' for even more concise type-checking / casting:

    fun doAlgebraicAddition(e: Expression): Int =
        when (e) {
            is Num -> {                                 // when cases can have blocks in curly braces. you still precede them with an arrow
                println("found an actual number")
                e.value
            }
            is Sum ->
                doAlgebraicAddition(e.right) + doAlgebraicAddition(e.left)
            else ->
                throw IllegalArgumentException("unknown expression")
        }


looping is generally very similar to other languages:

    while(true) {
        ...
    }

    do {
        ...
    } while(true)


kotlin can use ranges to loop over things, similar to python:

    val oneToTen = 1..10                // ranges can be created with the .. operator
                                        // ranges are inclusive - 10 is part of this range
    for (x in oneToTen) {
        ...
    }

    for (x in 100 downTo 1 step 2) {    // another syntax for creating a range. this time we count down by 2s though
        ...
    }

    for (x in 1 until 10) {             // the until keyword can be used to create a non-inclusive range. this range will not include 10
        ...
    }

    for (letter in 'a'..'z') {          // ranges can be between characters
        println(letter)
    }


you can loop over more complex collections like trees:

    val letterToNumber = TreeMap<Char, Int>()

    for (letter in 'a'..'z') {
        val num = letter.toInt()
        letterToNumber[letter] = num
    }

    for ((letter, num) in letterToNumber) {
        println("$letter = $num")
    }


collections also have a convenient withIndex() method you can use to get the elements index along with the element:

    val listOfNames = arrayListOf("john", "paul", "george", "ringo")
    for ((index, name) in listOfNames.withIndex()) {
        println("beatle number $index: $name")
    }


the 'in' operator can test for membership in a collection:

    fun isLetter(char: Char) = char in 'a'..'z' || char in 'A'..'Z'
    fun isNonDigit(char: Char) = char !in '0'..'9'


you can create a range from any class that implements the Comparable interface, including your own custom types (CH7)

handle exceptions as in other languages.
    with try/catch/finally handle exceptions, and the throws keyword can throw an exception:

    fun readNumber(reader: BufferedReader): Int? {
        try {
            val line = reader.readLine()
            return Integer.parseInt(line)
        } catch(e: NumberFormatException) {
            println("invalid number format")
            throw e
        } finally {
            reader.close()
        }
    }


in Java you have to declare all checked exceptions that a function can throw explicitly in its signature
    kotlin does not distinguish between checked and unchecked exceptions.
        so you don't need to add a throws statement to a kotlin function signature.

note that the try exception returns a value:

    fun readNumber(reader: BufferedReader) {
        val number = try {
            Integer.parseInt(reader.readLine()
        } catch (e: NumberFormatException) {
            return                                      // will return null
        }

        println(number)
    }


========================================================
CHAPTER 3: DEFINING AND CALLING FUNCTIONS
========================================================

kotlin uses collections from the Java collections framework, but provides library functions for instantiating them:

    val set = hashSetOf(1, 7, 53)
    val list = arrayListOf(1, 7, 53)
    val map = hashMapOf(
        1 to "one",
        7 to "seven",
        53 to "fifty-three"
    )

    println(set.javaClass)              // class java.util.HashSet
    println(list.javaClass)             // class java.util.ArrayList
    println(map.javaClass)              // class java.util.HashMap


even though we're using Java collections, kotlin extensions allow us to do much more with them (future chapters will discuss this more):

    val strings = listOf("john", "paul", "george", "ringo")
    println(strings.last())

    val numbers = setOf(1, 14, 3)
    println(numbers.max()


unlike Java, kotlin supports named parameters and default values:

    fun <T> joinToString(collection: Collection<T>, separator: String = ", ") {
        ...
    }

    val list = arrayListOf(1, 7, 53)
    joinToString(list, separator = "; ")


in Java you often end up with alot of overloaded functions for different combinations of parameters.
    since Kotlin has default parameters you don't need to do this as much.

    but if you're calling kotlin functions that have default parameters from Java you still have to specify all parameters, unfortunately.

    to fix this you can annotate a kotlin function with @Jvm-Overloads
        this will tell the compiler to auto-generate overloaded methods, omitting each of the default parameters one by one, starting at the end.
        so if using this you should ensure all your default parameters come at the end of the function signature


functions can be declared at the top-level of files in kotlin (unlike in Java).
    the function will belong to the package for that file, and you can import the package to use the function.

in Java to implement utility methods you typically had to create classes which contained a bunch of static methods.
    if you need to call a kotlin top-level method from Java you must know what class / static method it'll will be compiled as.
    the class name is actually based on the kotlin file name.
    though you can change the name of the class the JVM will generate here via the @JvmName annotation (see pg 50):

    // join.kt
    package strings                             // add our utility function to the strings package

    fun joinToString(...) { ... }


    // caller.java
    import strings.JoinKt                       // the kotlin file name was used as the class name for the static method,
                                                // and it was inserted into the strings package
    val list = arrayListOf(1, 7, 53)
    JoinKt.joinToString(list, separator = "; ")


properties can also be declared at the top-level (sometimes useful for defining constants).
    by default these properties are exposed to Java code using getters / setters synthesized for them (just like other properties).
    if you want the property exposed as a static final instaed, precede its declaration with the 'const' keyword (this only works on primitives)

kotlin has extension functions which work basically like swift extensions - methods of a class defined outside of it.
    from within the function you'll have access to the classes public members, but not its private or protected members.
extension functions are actually compiled to static functions that take the receiving object instance as their first argument.
    the name of the class will be derived from the file name (like with other top-level functions):

    // StringUtils.kt
    package extensions

    fun String.lastChar(): Char = this.get(this.length - 1)             // you can omit 'this' but I included it here for clarity

    println("Kotlin".lastChar())                                        // compiled to StringUtilsKt.lastChar(string: String)


to use an extension function defined elsewhere you may need to import it:

    import extensions.lastChar

    import extensions.*

    import extensions.lastChar as last      // uses an alias. this allows you to avoid name conflicts.
                                            // if this were a regular class or function you could refer to it with a fully qualfiied name,
                                            // but you can't refer to an extension function with a fully qualified name

to call an extension function from java code just call the compiled static method:

    char c = StringUtilsKt.lastChar("Java");


you can also extend generic functions:

    fun <T> Collection<T>.joinToString(         // extend all collections
        separator: String = ", ",
        prefix: String = "(",
        postfix: String = ")"
    ) { ... }

    fun Collection<String>.joinToString(        // extend just string collections
        separator: String = ", ",
        prefix: String = "(",
        postfix: String = ")"
    ) { ... }


since extension functions are static they can't be overridden in subclasses.
    also it's determined at compile time which extension function gets called.
        so you can't use polymorphism to determine which extension function gets called at runtime.

if a class has a method and an extension function with the same signature the method will be called, not the extension function

extension properties also work like in swift - they must always be computed (using a getter / optional setter):

    // StringUtils.kt
    var StringBuilder.lastChar: Char
        get() = get(length - 1)
        set(value: Char) {
            this.setCharAt(length - 1, value)
        }

    val stringBuilder = StringBuilder("Kotlin?")
    stringBuilder.lastChar = '!'


to access an extension property from Java remember to invoke the getter explicitly:

    char c = StringUtilsKt.getLastChar("Java");


use the vararg keyword to declare a variadic parameter, and the spread operator '*' to pass a collection as a variadic argument:

    fun listOf<T>(vararg values: T): List<T> { ... }

    val list = listOf(2, 3, 5, 7, 11)

    val array = arrayOf<Int>(1, 2, 3, 4, 5)
    val list2 = listOf(*array)                      // spread operator usage


to create maps you use 'to' function.
'to' isn't a built-in language construct, but a special kind of function invocation called an infix call.
    an infix call is a special syntax for invoking methods with 1 parameter.
    the method name is placed between the target object and the parameter:

    val map = mapOf(
        1 to "one",             // the same as 1.to("one")
        2 to "two",
        3 to "three"
    )


the 'infix' keyword can declare any 1-parameter function an infix function. then you can use infix call syntax with it:

    infix fun Any.to(other: Any) = Pair(this, other)            // the real signature of to() actually uses generics


kotlin also supports destructuring declaration syntax, like other languages:

    val (num, word) = 1 to "one"

    for ((index, element) in collection.withIndex()) {
        ...
    }


as with collections, kotlin defines alot of extension functions for working Java strings.

    val array = "12.345-6.A".split(".", "-")                // kotlins split method can take multiple delimiters.
    println(array)                                          // [12, 345, 6, A]


you can also use triple quoted strings to avoid having to escape characters, use newlines, etc.
    infact you can't use escape characters like \n in a triple quoted string:


    fun parsePath(path: String) {
        val regex = """(.+)/(.+)\.(.+)""".toRegex()             // toRegex() is another string extension method that returns a Regex object
        val matchResult = regex.matchEntire(path)
        if (matchResult != null) {
            val (dir, filename, extension) = matchResult.destructured           // the destructured property will be discussed in CH7
            println("Dir: $dir, Filename: $filename, Extension: $extension")
        }
    }

    val asciiArt = """| //
                     .|//
                     .|/ \"""
    println(asciiArt.trimMargin("."))               // trimMargin() trims the lefthand side of a triple quoted string up to and including a delimiter


    val price = """${'$'}9.99"""                    // since you cant escape characters in triple quoted strings,
                                                    // if you need a $ symbol you must use an embedded expression


there are other libraries online that provide convenient kotlin-extensions to common Java libraries like Spring

in kotlin nested functions have access to the scope of the containing function:

    fun tendToDog(dog: Dog) {
        if (dog.isBored()) {
            walk()
        }

        fun walk() {
            dogWalkTime = "14:00"
            dog.walk()
            dog.giveTreat()
        }
    }


========================================================
CHAPTER 4: CLASSES, OBJECTS, AND INTERFACES
========================================================

kotlins interfaces can contain abstract and default methods, but can't contain state (same as swift / java).

in kotlin a class can only extend one class, but can implement multiple interfaces (same as swift / java)

if you conform to two interfaces, but each of them have a default method with the same function signature, the compiler will throw an error.
    to resolve this error you'll have to implement the method in your own class.


    interface Clickable {
        fun click()
        fun showOff() = println("I'm a button! wooo")       // default implementation
    }

    interface Focusable {
        fun showOff() = println("I'm a focusable element! wooo")
    }

    class Button: Clickable, Focusable {
        override fun click() = println("Hello!")            // the override keyword is mandatory in kotlin (different from java)
                                                            // this ensures you don't accidentally override a method that's added to the interface later

        override fun showOff() {                // must provide implementation since there are conflicting default implementations
            super<Clickable>.showOff()          // but you can call the supertypes default methods via super
            super<Focusable>.showOff()          // with the supertypes name in the angle brackets
        }
    }


kotlin abstract classes / methods do not have default implementations, and are open by default. 
kotlin regular classes are final by default. 
    to subclass them you must mark them as 'open'
    to allow methods / properties to be overridden you must also mark them as 'open'


    abstract class Animal {
        abstract fun walk() 

        open fun breath() { ... }

        fun sleep() { ... }
    }

    open class Dog : Animal {
        override fun walk() { ... }                 // overridden methods will be open by default, but you can change them to final 
    }


note that you don't use final / abstract / open in interfaces, only in classes. 

note that smart casting (syntax for automatically doing typecasting) only works with val (constant) properties that are final. 
    final here allows the runtime to know that no custom accessor exists in a subclass somewhere. 
        the runtime can then assume the type hasn't been altered after the type check operation.


the default visibility in Java is package-private. this doesn't exist in kotlin. 
    kotlin only uses packages as namespaces, it doesn't use them for visibility control. 

kotlin has 4 visibility specifiers: 

    public              visible everywhere 
    internal            visible in a module 
    protected           visible in subclasses 
    private             visible within the class, or within the file if used at the top-level 

public is the default visibility in Kotlin for properties / methods (strange) 

in java there was a problem with its default visibility, package-private. 
    external code could declare itself as part of the package and access those properties. 
    kotlins internal fixes this. the code must be within the module to have access. 
    note that kotlin defines a module as a set of files compiled together. 

remember that extension functions won't be able to access private / protected class members 
also you can't see the private / protected members of a nested class 


in Java, nested classes apparently have a reference to their parent classes. I'm not sure why or how this is possible, but it is. 
    to prevent this in Java you must declare the nested class as static. 
but in Kotlin nested classes are static by default. 
    to make nested classes behave like in java, with a reference to the parent, declare it using the 'inner' keyword. 


    class Outer {
        inner class Inner {
            fun getOuterReference(): Outer = this@Outer         // you can get a reference the parent class via this@Outer 
        }
    }


to create a sealed class mark the superclass with the 'sealed' keyword'. 
    in kotlin 1.0 all direct subclasses had to be nested within the superclass. 
    kotlin 1.1 relaxed this, and allowed you to merely put all the subclasses in the same file as the sealed class. 
sealed classes allow your subclasses to be typechecked and used like enums: 


    sealed class Expression {
        class Num(val value:  Int) : Expression() 
        class Sum(val left: Expression, val right: Expression) : Expression() 
    }

    fun doAlgebraicAddition(e: Expression): Int =
        when (e) {
            is Expression.Num -> e.value 
            is Expr.Sum -> doAlgebraicAddition(e.right) + doAlgebraicAddition(e.left) 
        }


you cannot declare sealed interfaces, only sealed classes. 


kotlin classes can have a primary constructor, secondary constructors, and an init block 
    the init block is meant to be used in combination with the primary constructor, which has an abbreviated syntax 


    class Dog constructor(food: Food) {                 // the constructor keyword is optional and usually omitted
        val bowl: Bowl                                  // but it's needed if you're annotating or modifying access to the constructor 

        init {                                          // here you do initialization that would typically be in the primary constructor 
            bowl = Bowl(food: food)
        }
    }

    class Cat(val food: Food, color: Color = .black)    // preceding this parameter w/ 'val' will cause a property for it to be autogenerated 

    class Rat(_food: Food, isFromSewers: Boolean) {
        var food = _food                                // you can bypass the init block and assign the primary constructor's parameters directly 
    }


    val rat = Rat(Food(), isFromSewers = true)          // keyword arguments work in some cases 


if your class has a superclass the primary constructor must initialize the superclass. 
    you do this by calling the superclass's primary constructor directly and passing parameters to it:

    class SewerRat(food: Food) : Rat(food, isFromSewers: true) { 
        ... 
    }


if you don't declare any constructor for a class a default constructor that does nothing will be generated automatically: 

    class Fungus
    class Mushroom : Fungus()           // if you inherit from a class with a default constructur you still must invoke it. 

    val fungus = Fungus()
    val mushroom = Mushroom() 


you can ensure a class can't be instantiated by external code, but allow the class itself to still be used, via making the constructor private: 

    class Fish private constructor() {      // since we're modifying access to the constructor we must use the constructor keyword 
        ... 
    }


secondary constructors aren't that common, since default parameters in the primary provide alot of flexibilty, but they can still be useful. 

you don't have to declare a primary constructor, it's legal to rely on just secondary constructors. 
    if the class has no primary constructor then each secondary constructor has to initialize the super class, or delegate to a constructor that does.
    but using only secondary constructors is mainly useful when inheriting from framework or java classes that themselves rely on multiple constructors.
        although sometimes it can useful to have multiple constructors with very different parameter lists: 



    class View {
        constructor(ctx: Context) { ... }
        constructor(ctx: Context, attr: AttributeSet) { ... }

        constructor(ctx: Context, name: String): this(ctx) {        // 'this' allows you to call another constructor owned by this class
            println("my name is: ", name)
        }
    }

    class CustomButton : View {                             // View doesn't define a primary constructor 
        constructor(ctx: Context) : super(ctx) {            // so here we must invoke the superclass constructor via super() 
            ... 
        }
        constructor(ctx: Context, attr: AttributeSet) : super(ctx, attr) {    
            ...
        }
    }


here are some interesting ways to implement a property defined in an interface. 
    note that an interface can contain default implementations for properties by using getters / setters. 
    also note you can't access the backing field in an interfaces setter: 


    interface Animal {
        val name: String 
        val nameTag: String                             // default implementation for property
            get() = "$hi, my name is {name}"
    }

    class Dog(override val name: String) : Animal                       // use the override keyword in a primary constructor & synthesize the property 

    class Cat(val color: Color) : Animal {
        override val name: String                                       // override the property and use a custom getter
            get() = "${color.rawValue} cat"                             // behaves like a computed property, there's no stored data backing it 
    }

    class Bat(idNumber: Int) : Animal {
        override val name = getBatNameById(idNumber)                    // set the overridden property using a property initializer 

        var speed: Int = 0
            get() {
                println("current speed is $field")                      // 'field' within a getter lets you read the backing fields value 
                return $field
            }
            private set(value: Int) {                                   // notice you can assign access levels for the getter / setter itself  
                println("flap flap flap")
                println("speed changed from $field to $value")
                field = value                                           // 'field' within a setter lets you read & modify the backing field
            }
    }


kotlin has certain methods that you often should override (like in Java): 

    toString()                          // mainly used in logging / debugging, but sometimes in other contexts 
    equals()                            // will test for object refrences unless overridden. 
    hashCode()                          // always override together with equals(). used for comparisons in sets and elsewhere 
    copy()


    class Dog(val name: String, val bone: Bone) {
        override fun toString() = "my name is ${name}"

        override fun isEquals(other: Any?): Boolean {
            if (other == null || other !is Client)              // !is checks that an object isn't a particular type  
                return false 
            return name == other.name && bone == other.bone 
        }

        override fun hashCode(): Int = name.hashCode() * 31 + bone.hashCode()

        fun copy(                                               // no override required apparently 
            name: String = this.name, 
            bone: Bone = this.bone
        ) {
            Dog(name, bone)
        }
    }

    val dog = Dog("java", Bone()) 
    val dog2 = dog.copy(name="yogi")            // you must call copy() explicitly to use it 


data classes come with these 4 implemented using the properties in the primary constructor.

fortunately in kotlin you use == to compare objects, and this calls equals() - unlike in java where you always call equals() 
kotlin === will always compare object references, even after overriding equals() 

note that data classes auto-generated copy() method is a shallow copy. to get a deep copy you must implement copy() yourself 

it's strongly encouraged to use immutable properties in your data classes. 
    otherwise if you use a data class as a key in a hashMap, then modify one of the data classes properties, the key will no longer work 


kotlin has built-in language support for delegateion via the 'by' keyword 
the following two classes are equivalent: 

    class DelegatingCollection<T> : Collection<T> {
        private val innerList = arrayListOf<T>() 

        override val size: Int get() = innerList.size
        override fun isEmpty(): Boolean = innerList.isEmpty()
        override fun contains(element: T): Boolean = innerList.contains(element)
        override fun iterator(): Iterator<T> = innerList.iterator()
        override fun containsAll(elements: Collection<T>): Boolean = innerList.containsAll(elements)
    }

    // no method implementations are required. calls not implemented are delegated to innerList.
    // the compiler generates the innerList property and delegate methods for you
    class DelegatingCollection<T>(
        innerList: Collection<T> = ArrayList<T>()
    ) : Collection<T> by innerList {                    // here we specifically delegate the Collection<T> part of our interface to innerList
        ... 

        override fun isEmpty(): Boolean {               // override a method to prevent delegating it to innerList
            innerList.isEmpty && queue.isEmpty() 
        }
    }

    
    pg 93, 4.4













