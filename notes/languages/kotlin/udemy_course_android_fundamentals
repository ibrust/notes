
layout elements that contain other views (i.e. LinearLayout, ConstraintLayout, etc.) are called "ViewGroups" or "Containers" 

the unit type most commonly used in Android for width / height is density independent pixels (dp):
    <ImageView
        android:layout_width="100dp"
        android:layout_height="100dp" />

to add an image to the project
    1) open the resource manager tab on the left 
    2) click on the "drawable" tab 
    3) drag & drop the image into the tab 
    4) name the resource - it should be all underscores and snake case
    5) set ImageView's src attribute to the image location using @drawable

        <ImageView
            src="@drawable/image_name"
            android:layout_width="100dp"
            android:layout_height="100dp" />


padding applies space within the element, margins apply space around the element 


RadioGroup is a type of LinearLayout that groups RadioButton elements together, and ensures only one is selected at a time 

    <RadioGroup 
        android:layout_width="wrap_content"
        android:layout_height="wrap_content"
        android:orientation="horizontal">

        <RadioButton 
            android:layout_width="wrap_content"
            android:layout_height="wrap_content"
            android:text="option 1" />
        <RadioButton 
            android:layout_width="wrap_content"
            android:layout_height="wrap_content"
            android:text="option 2" />
    </RadioGroup>


an EditText element is like a textfield 

    <EditText 
        android:input_type="number"
        android:hint="Card Number"
        android:layout_margin="8dp"
        android:layout_width="wrap_content"
        android:layout_height="wrap_content" />


in MainActivity, in its onCreate() method there’s a call setContentView(R.layout.activity_main) which sets the main view 
    here R.layout.activity_main means resource file > layout file > activity_main 
        (activity_main.xml is the name of the XML file in this demo app)

remember the folder path from the root folder java/ has to match the package path at the top of the java file 

in the project view click on the gear icon, go to Tree Appearance > Compact Middle Packages. 
    this option will compact the deeply nested empty folders


add this to the bottom of onCreate() to show a simple toast: 

	Toast.makeText(this, "Show a toast", Toast.LENGTH_LONG).show()


to get a reference to a view element from within the java call findViewById()
	you assign the view an ID in the XML then pass it into that method 

	// XML file
	<Button
		android:layout_width=“100dp”
		android:layout_height=“100dp”
		android:id=“@+id/unique_id” />					// you must add the @+id/ prefix before the id name

	// Java file
	Button button1 = findViewById(R.id.unique_id);

	button1.setOnClickListener(new View.OnClickListener() {
            @Override 

            public void onClick(View v) {

                // in a lambda you must specify what this refers to - in this case MainActivity.this

                Toast.makeText(MainActivity.this, "Show a toast", Toast.LENGTH_LONG).show()
            }
        })

An activity provides the window in which the app draws its UI. This window typically fills the screen, but may be smaller than the screen and float on top of other windows. Generally, one activity implements one screen in an app.

the main activity is the first screen to appear when the app is launched 

activities are loosely coupled. activities can start / navigate to activities belonging to other apps. 

To use activities you must register information about them in the app’s manifest, and you must manage activity lifecycles

LinearLayout is kind of like a stack view
	RelativeLayout is kind of like a regular auto layout view - all the views within are relative, and need additional constraints.
	to layout views relative to one another within RelativeLayout you must give them IDs. 

	<RelativeLayout 
		android:layout_height=“match_parent”
		android:layout_width=“match_parent” />

		<TextView
			android:id=“@+id/textview_1“							// plus symbol when you’re adding the id 
			android:layout_centerHorizontal=“true”
			android:layout_height=“wrap_content”
			android:layout_width=“wrap_content”
			android:textSize=“24sp”								// sp is specifically for text, it makes the size adjustable
			android:text=“Hello!” />

		<TextView
			android:id=“@+id/textview_2“
			android:layout_centerHorizontal=“true”
			android:layout_below=“@id/textview_1”					// notice there’s no + symbol now 
			android:layout_height=“wrap_content”
			android:layout_width=“wrap_content”
			android:textSize=“24sp”
			android:text=“Hello!” />

	</RelativeLayout>



here’s an example of how to add a MaterialUI CardView (a popular google component) to your project
	you can also just import the enitre MaterialUI library if you want: 

	// build.gradle (groovy)
	dependencies {
   		implementation "androidx.cardview:cardview:1.0.0"		// fetches the remote dependency during the build phase
	}

	// XML file 
	<androidx.cardview.widget.CardView 
		android:layout_height=“wrap_content”
		android:layout_width=“200dp”
		android:id=“@+id/cardview1” >

		<LinearLayout 									// apparently CardView doesn’t give you much control over its child elements 
			android:layout_height=“wrap_content”		// so we create a LinearLayout and then add children in there 
			android:layout_width=“match_parent”
			android:orientation=“horizontal”>

			// add child views here 

		</LinearLayout>

	<androidx.cardview.widget.CardView />


note that in a RelativeLayout, to constrain elements to one another, they should be direct siblings of one another.
	so you wouldn’t constrain one element to another siblings child, for example 

when you’re adding images to your resources… if they’re high density make sure you specify the density as high density. 
	if you don’t specify this, and Android puts the high res photo in a standard drawable folder… 
    then it tries to draw this on a high-res phone. it will upscale the image, making it even more dense. 
    this will cause the app run out of memory to crash because the image is too large. 

android:gravity positions an elements children 
android:layout_gravity positions an element within its layout 

there’s a ScrollView element. it can also only have 1 child - so use a RelativeLayout or LinearLayout

	<ScrollView
		android:layout_height=“match_parent”
		android:layout_width=“match_parent”>

		<RelativeLayout
			android:layout_height=“wrap_content”    // wrap_content allows RelativeLayout content to exceed the height of the ScrollView
			android:layout_width=“match_parent”>
		</RelativeLayout>

	</ScrollView>


the build.gradle file is used by gradle for fetching dependencies and compiling.
	the AndroidManifest.xml contains metadata used by Android (the OS, build tools, and Google Play store)
	it must list all components used in the app: activities, services, broadcast receivers, and content providers 
		for example, it’s used to declare device capabilities of these various components, and specifies the hardware / software requirements  
	it also specifies permissions for the app to access protected parts of the OS or other apps, or to allow other apps access 

	<activity
    	android:name=".MainActivity"
   		android:exported="true">
    		<intent-filter>
        		<action android:name="android.intent.action.MAIN" />				// this code must be in the activity that first launches the app
        		<category android:name="android.intent.category.LAUNCHER" />
    		</intent-filter>
	    </activity>
	<activity android:name=“.SecondActivity” />						// if there’s no info to put inside you use the self closing tag instead


an Intent allows you to move between one Activity (screen) and the next. 

	// AndroidManifest.xml
	<activity android:name=“.SecondActivity” 
		android:label=“Second Screen title”			// label sets the title for this activity in the nav bar. if unspecified it uses the parents title 
		android:parentActivityName=“.MainActivity”		// setting the parent will show a back button that takes you back to the parent activity 
		/>


	//  MainActivity.java
	@Override
	protected void onCreate(Bundle savedInstanceState) {
		super.onCreate(savedInstanceState);
		setContentView(R.layout.activity_view);
		someSubview = findViewById(R.id.someSubview);			// you can add an onClickListener to any view

		someSubview(new View.OnClickListener(){
			@Override public void onClick(View v) {
				Intent moveToSecondView = new Intent(MainActivity.this, SecondActivity.class);			// this is an explicit intent - we’re going to
				startActivity(moveToSecondView);													// a known location within our app
			}
		});
	}


here’s how you create a ListView: 

	// XML file 
	<ListView 
		android:id=“@+id/list_view
		android:layout_width=“match_parent”
		android:layout_width=“match_parent” />

	//  MainActivity.java
	@Override
	protected void onCreate(Bundle savedInstanceState) {
		super.onCreate(savedInstanceState);
		setContentView(R.layout.activity_view);

		ListView listView = findViewById(R.id.list_view);

		String[] itemsInList = {
			“Wukong”,
			“Rammus”,
			“Kindred”
		}
		// ArrayAdapter converts an array of viewmodels into an array of views
		ArrayAdapter<String> stringToViewAdapter = new ArrayAdapter<>(
			this,
			android.R.layout.simple_list_item_1,				// simple_list_item_1 is a native Android XML layout that only shows a label
			itemsInList									// so it only needs a string as its viewmodel
		);

		listView.setAdapter(stringToViewAdapter);			// pass the adapter and an array of views will be constructed for our listView 
	}


you can also create implicit Intents. These can do things like navigate to a Android native app. 
	here’s an example of opening up gmail:

	//  MainActivity.java
	@Override
	protected void onCreate(Bundle savedInstanceState) {
		super.onCreate(savedInstanceState);
		setContentView(R.layout.activity_view);

		sendEmailButton = findViewById(R.id.sendEmailButton);

		sendEmailButton(new View.OnClickListener(){
			@Override public void onClick(View v) {
				Intent launchGmailIntent = new Intent(Intent.ACTION_SENDTO);		// ACTION_SENDTO specifically launches the native mail app
				launchGmailIntent.setData(uri.parse(“mailto:helpdesk@walmart.com”);	// set the data to send to the new activity you’re launching
				startActivity(launchGmailIntent);									// in this case gmail expects a mailto: uri as data 
			}
		});
	}



surprisingly you must download the recyclerview (and many other google androidx views) as a dependency to use it: 

	// build.gradle 
	dependencies {
		implementation “androidx.recyclerview:recyclerview:1.3.1”
	}

	// main recyclerView's XML file 
    // you can configure a recyclerViews layout like a collectionView. layoutManager facilitates that
	<androidx.recyclerview.widget.RecyclerView 
		xmlns:android=“http://schemas.android.com/apk/res/android” 
		xmlns:app=“http:/schemas.android.com/apk/res-auto”			// the app namespace is used for components that aren’t native
        android:id=“@+id/main_recycler_view”
		android:layout_width=“match_parent”
		android:layout_height=“match_parent”
		app:layoutManager=“androidx.recyclerview.widget.LinearLayoutManager” />


	// cell_layout.xml - the RecyclerView cell’s XML file - note that the names of XML files must always be lowercase, so use snakecase 
	<androidx.cardview.widget.CardView
        xmlns:app="http://schemas.android.com/apk/res-auto"         // cardCornerRadius is not a native property
        xmlns:tools="http://schemas.android.com/tools"              // properties in the tools namespace will only show up during development
		android:layout_width=“match_parent”
		android:layout_height=“wrap_content”
        android:layout_margin="12dp"                   // note that CardView ignores padding. It works similar to a FrameLayout
        app:cardCornerRadius="6dp"
        >

		<RelativeLayout
			android:layout_width=“match_parent”
			android:layout_height=“wrap_content”>

            <androidx.cardview.widget.CardView              // since ImageView doesn't allow you to round the corners
                android:layout_width=“wrap_content”         // nesting it in a CardView is a quick and dirty way to do that
			    android:layout_height=“wrap_content”        // but there are libraries for working with images you can use instead
                android:id="@+id/icon_wrapper"
                android:layout_margin=“12dp”
                app:cardCornerRadius="6dp"
                app:cardElevation="0dp"                     // get rid of any shadow since we don't want that here
                >
                <ImageView 
                    android:layout_width=“80dp”
                    android:layout_height=“80dp”
                    tools:src=“drawable/ic_launcher_background”			    // this is a native image. it's in tools so it'll show up during debug only
                    android:id=“@+id/cell_icon”
                    android:scaleType="centerCrop"                          // the way Android will rescale the image
                    />                                                      // fitCenter, centerCrop, and fitXY are commmon scaleTypes
            </androidx.cardview.widget.CardView>

			<TextView
				android:layout_width=“match_parent”
				android:layout_height=“wrap_content”
				android:text=“title”
                android:fontFamily="sans-serif-medium"
                android:textColor="#222222"
                android:textSize="18sp"
				android:id=“@+id/cell_textfield_title”			// there’s also a layout_toEndOf that is used for localization 
				android:layout_toRightOf=“@id/icon_wrapper”		// in US it’ll put the textview to the right of the imageView 
				android:layout_alignTop=“@id/icon_wrapper />	// for countries that read right to left it will put the textview to the left

			<TextView 
				android:layout_width=“match_parent”
				android:layout_height=“wrap_content”
				android:text=“description”
                android:fontFamily="sans-serif-light"
                android:textColor="#888888"
                android:textSize="14sp"
				android:id=“@+id/cell_textfield_description”
				android:layout_toRightOf=“@id/icon_wrapper”
				android:layout_below=“@id/cell_textfield_title”
				android:layout_marginTop=“4dp” />
 
		</RelativeLayout> 
	</androidx.cardview.widget.CardView>

 
	// activity JAVA file 
 
	@Override 
	protected void onCreate(Bundle savedInstanceState) { 
		super.onCreate(savedInstanceState); 
		setContentView(R.layout.activity_view);

        // the instructor says if you have alot of images try to keep the image size to around 100-200KB if possible 
        // also he set the image density to "no density" when he imported them to prevent resizing 
        // he says later we'll use some special library to optimize for image performance and we won't have to do this
        CellData[] data = {
            new CellData("first cell", "test data", R.drawable.icon1),          // note the type of R.drawable here is int
            new CellData("second cell", "test data", R.drawable.icon2)
        };

        RecyclerView recyclerView = findViewById(R.id.main_recycler_view);
        CellDataAdapter customAdapter = new CellDataAdapter(data);
        recyclerView.setAdapter(customAdapter);
	}


    // cell data JAVA file 
    public class CellData {
        String title;
        String description;
        int icon;                   // the resource ID (accessed via R.drawable.icon_name) returns an integer

        CellData(String title, String description, int icon) {
            this.title = title;
            this.description = description;
            this.icon = icon
        }
    }

    // custom adapter JAVA file 
    // the generic here specifies the viewholder type for the adapter
    public class CellDataAdapter extends RecyclerView.Adapter<CellDataAdapter.CustomViewHolder> {           

        private CellData[] data;                // you need a property to store the data passed into the adapter

        public CellDataAdapter(CellData[] data) {
            this.data = data
        }

        // you must implement these 3 abstract methods from RecyclerView.Adapter 
        @Override 
        public int getItemCount() {
            return data.length;
        }

        @NonNull 
        @Override 
        public CustomViewHolder onCreateViewHolder(@NonNull ViewGroup parent, int ViewType) {
            // we need to pass in our cell view to CustomViewHolder's constructor, that's what it expects
            // to do that we must inflate the view (create a programmatic view from a layout file)
            // for the context - we're not in the main activity, so we can't just use "this". we have to get the context from the ViewGroup parent.
            View view = LayoutInflater.from(parent.getContext()).inflate(
                R.layout.cell_layout,
                parent,                             // the ViewGroup we already have access to - given to us by the adapter automatically
                false                               // boolean for attachToRoot - just put false, read docs for more info
            );
            return CustomViewHolder(view);
        }

        // called on each cell when its view needs to be updated
        @Override 
        public void onBindViewHolder(@NonNull CustomViewHolder holder, int position) {          
            holder.bind(data[position]);
        }

        // static is convenient here so we don't have to construct a new instance to use this class
        // RecyclerView.ViewHolder is basically the viewmodel for a RecyclerView cell 
        // when cells are reused the viewHolder will change but the underlying view will remain the same 
        static class CustomViewHolder extends RecyclerView.ViewHolder {
            private ImageView iconView;
            private TextView titleTextView;
            private TextView descriptionTextView;

            public CustomViewHolder(@NonNull View itemView) {               // required constructor 
                super(itemView);
                // here we take the infalted views and store a reference to them in the adapter. 
                // this way we can update the views directly using the datum in bind().
                // you must call findViewById() off of itemView because it has the right context
                iconView = itemView.findViewById(R.id.cell_icon);
                titleTextView = itemView.findViewById(R.id.cell_textfield_title”);
                descriptionTextView = itemView.findViewById(R.id.cell_textfield_description");
            }

            // kind of like applyModel() - this is just a method to be called in onBindViewHolder() to update the view
            public void bind(CellData datum) {
                iconView.setImageResource(datum.icon);
                titleTextView.setText(datum.title);
                descriptionTextView.setText(datum.description);
            }
        }
    }


java / kotlin get compiled to java bytecode, which then gets compiled into DEX bytecode by the DEX compiler. 
	the DEX bytecode runs in either the ART (android runtime) or, prior to API 21 (Lollipop), its precedessor the DVM (Dalvik Virtual Machine)
	the ART / DVM are Android's modified version of the JVM 


here's how to write kotlin code: 

	var age: Int = 37
	val name: String = "Ian Rust"				// val is a constant, like let 

	var hairColor = "Blonde"					// hairColor will be a String variable - the type can be inferred



here’s how to code an activity in Java: 

	class MainActivity : AppCompatActivity() {
		override fun onCreate(savedInstanceState: Bundle?) {
			super.onCreate(savedInstanceState)
			setContentView(R.layout.activity_main)

			val button1: Button = findViewById(R.id.button1)
			button1.setOnClickListener {					// this is an interface with 1 method so we can use a callback like this
				handleButtonClick()
			}
		}
	}

	private func handleButtonClick() {
		val textfield1: TextInputEditText = findViewById(R.id.materalUITextfield1)
		val toastString = textfield1.text.toString() + “ entered”
		Toast.makeText(this, toastString, Toast.LENGTH_LONG).show()
	}


kotlin handles nulls safely like Swift does:

	var personsName: String? = null			 	// you must assign optionals an initial value in kotlin, it won’t let you default to null 
	personsName?.toUpperCase()

	personsName!!.toUpperCase()				// forced unwrapping is done with !! 
	
	val helloString = “my name is: “ + personsName 			// helloString will actually be null if personsName is null here


you can output to LogCat in the code:

	Log.d(“tag name here”, “message here”)


kotlin introduced string templates, which are basically format strings: 

	val firstName = “Ian”
	val lastName = “Rust”
	val greeting = “My name is $firstName $lastName”			// if you interpolate a non-string kotlin will convert it by calling toString() on it 

here’s how you write a function: 

	fun dogBark() {							// no need to specify void return type
		println(“bark”)						// note that kotlin uses the word Unit instead of void 
	}

	fun feedDog(newBones: Int): Unit {			// Unit is void, you don’t need to specify this but you can 		self.bones = self.bones + newBones	}
	
	fun getBones(): Int {
		return self.bones
	}

	fun square(number: Int): Int = number * number			// this is a function expression
														// since it’s one line it can infer the return statement and {} braces, like in swift 	
	func square(number: Int) = number * number 				// function expressions (1 liners) can even infer the return type 


there are 4 levels of access in Java: 
	public 						can be accessed from any file, any class, any package 
	protected 					can be accessed from either a class in the same package or a subclass 
	default 						used when you don’t explicitly specify an access level. can be accessed from a class in the same package only
	private 						can only be accessed from within the class 


note that in Java when you create a class instance you don’t need the new keyword: 

	var dog = Dog()


kotlin doesn’t let you use the .class property the way java does 
	when you create an intent you have to pass the Java class (the class compiled from the Kotlin). here’s how you do that in Kotlin: 

	val launchAddPayments = Intent(
		this, 
		AddPaymentsFragment::class.java				// ::class actually accesses the kotlin class, .java accesses the compiled class 
	)

be careful when integrating kotlin with Java classes. 
	the Java class won’t handle nulls using optionals, but its properties can still be null. Kotlin won’t be able to type-check for optionals. 
		this can be a problem when using Android framework code, for example.

	in Kotlin an integrated Java class’s data types are referred to as platform types, and are handled in a special way. 
		Platform types are non-denotable, meaning that you can't write them down explicitly in the language
		
		so your Kotlin variables can rely on type-inference (since this happens at runtime and the type will be known then) in these assignments, 
			or you can declare the type that’s expected explicitly. 
		
		thus you can choose to treat the platform-type as an optional or non-optional - it’s up to you, kotlin will allow either. 
			for safety I think you should just always handle these as optionals unless you have a good reason not to.

		sometimes the compiler / IDE need to display type information for these platform types even though they don’t have it, so they use the following syntax: 
			
			T! 								means T or T? 
			(Mutable)Collection<T>!			means a java collection of type T! - not really sure if the collection is mutable either
			Array<(out) T>!					means a java array of type T!

	But if the Java class’s types have nullability annotations these don’t have to be represented as platform types. 
		Instead we can compile using actual nullable or non-null Kotlin types. 

		there are several different ways of doing nullability annotations depending on the annotations package you use.
			it looks like our Android app is using @Nullable and @NotNull from the org.jetbrains.annotations package
	

in Android Activities do not have a reference to one another, so it’s not straightforward to pass data between them. 
You can add data to the Intent:

	// Wallet Activity 
	override fun onCreate(savedInstanceState: Bundle?) {
		…
	
		val addPaymentsIntent = Intent(this, AddPaymentsActivity::class.java)
	
		addPaymentsIntent.putExtra(“tpid”: “123”)					// putExtra adds data to the intent
		addPaymentsIntent.putExtra(“isSPFEnabled”: true)			// use key/value pairs 
		addPaymentsIntent.putExtra(“isPBBEnabled”: true)
	}

	// Add Payments Activity 
	override fun onCreate(savedInstanceState: Bundle?) {
		…

		val isSPFEnabled = intent.getBooleanExtra(“isSPFEnabled”)				// you need to know the type of the data you’re getting 
		val tpid = intent.getStringExtra(“tpid”)								// if the key doesn’t exist or you’re getting the wrong type this will return null 
		val isPBBEnabled = intent.getBooleanExtra(“isPBBEnabled”, false)		// false here will be the default value if this is null 
	}


here’s how you construct an array in kotlin:

	val dogNames: Array<String> = arrayOf(“Java”, “Chili”, “Big Red”)			// arrayOf is an array constructor in kotlin 


in kotlin a class constructor can be specified as a parameter list next to the class name 
	adding val/var in the parameter list makes the property static or dynamic
	you can also set access levels in the parameter list
	if you use this technique you don’t redeclare the properties within the class, they’re synthesized automatically 
	this technique allows properties to be non-null because these properties are demanded in the constructor 
	he said the properties are public by default (I don’t know why default isn’t used or if he misspoke here) 


	class Dog(var boneCount: Int, protected val favoriteToy: String?, name: String, isLoud: Bool) { 

		fun giveDogBone() {
			boneCount = boneCount + 1
		}

		override fun toString(): String {				// here’s how you override a method in kotlin - no longer an annotation
			return “my name is $name”
		}

		fun bark() = if (isLoud) “BARK” else “bark”				// use if/else for ternary expressions in kotlin 
	}

	val dog = Dog(1, “dragon”, “Java”, false)				// you don’t need the new keyword to create an object in Kotlin 


you can create data classes (kind of like a struct). 
	data classes come with some default behavior defined, such as a useful toString method() 
	read about java data classes for more info: 


	data class Bone(val color: String, val size: Int)


to pass a custom object as data through an Intent you have to serialize it.
	if you wanted to send the object to something outside the current runtime (another app, or close / restart the app and reconstruct the object), 
		you’d need to persist it (store it in the filesystem, a database, a different area of memory on the phone, etc.)
	you even have to use this persistence to pass data between Activities in the same app, surprisingly 
	an Intent automatically persists primitives and Strings, or anything that is serializable.
		but a custom object can’t be automatically persisted until it conforms to Serializable 

	 
	data class Bone(val color: String, val size: Int) : Serializable 	

	// Main Activity 
	val intent = Intent(this, DogLunchActivity::class.java)
	intent.putExtra(“bone”, Bone(yellow, 10))

	// Dog Lunch Activity 
	val bone: Bone = intent.getSerializableExtra(“bone”) as Bone	 		// note you must cast the type
																	// be careful with the “as” keyword, it will crash if it fails

kotlin supports lateinit variables. this allows you to not make the variable an optional type while still initializing it after the constructor call.
	if you use this you must carefully ensure that the property gets initialized before you try to use it 
	
	class Dog { 
		lateinit var leash: DogLeash 

		fun walkDog() {
			leash = DogLeash()

			leash.adjust()				// you don’t need to use optionals with a lateinit
		}

		func pullDogOutOfRoad() {
			leash.apply {				// apply() is a kotlin conveniece method
				reduceLength()		// everything within this apply block will be called off the leash instance 
				pullToward()
				giveSlack()
			}
		}
	}
	

to add a localizable string add it to the string.xml resource file. 
	you can reference these strings from within your XML files / code: 

	// strings.xml 
	<resources>
		<string name=“wallet_title”>Wallet</string>
		<string cvv=“enter_cvv”>Enter CVV</string>
	</resources>

	// main_layout.xml
	<TextView 
		android:layout_width=“match_parent”
		android:layout_height=“wrap_content”
		android:hint=“@string/enter_cvv”
		/>


the default strings go into res/values/strings.xml 
	for other languages you create a new values folder with a different suffix for the language type, and put a new strings file in it: 

	res/values-fr/strings.xml			french strings 
	res/values-ja/strings.xml			japanese strings 

